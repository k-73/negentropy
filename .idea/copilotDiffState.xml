<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.16)&#10;project(negentropy LANGUAGES CXX)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;include(FetchContent)&#10;FetchContent_Declare(&#10;  nlohmann_json&#10;  GIT_REPOSITORY https://github.com/nlohmann/json.git&#10;  GIT_TAG v3.12.0&#10;)&#10;&#10;FetchContent_Declare(&#10;  spdlog&#10;  GIT_REPOSITORY https://github.com/gabime/spdlog.git&#10;  GIT_TAG v1.15.3&#10;)&#10;&#10;FetchContent_Declare(&#10;  imgui&#10;  GIT_REPOSITORY https://github.com/ocornut/imgui.git&#10;  GIT_TAG v1.92.1&#10;)&#10;&#10;FetchContent_Declare(&#10;  glm&#10;  GIT_REPOSITORY https://github.com/g-truc/glm.git&#10;  GIT_TAG 1.0.1&#10;)&#10;&#10;FetchContent_Declare(&#10;  entt&#10;  GIT_REPOSITORY https://github.com/skypjack/entt.git&#10;  GIT_TAG v3.15.0&#10;)&#10;&#10;FetchContent_Declare(&#10;  magic_enum&#10;  GIT_REPOSITORY https://github.com/Neargye/magic_enum.git&#10;  GIT_TAG v0.9.7&#10;)&#10;&#10;FetchContent_Declare(&#10;  pugixml&#10;  GIT_REPOSITORY https://github.com/zeux/pugixml.git&#10;  GIT_TAG v1.14&#10;)&#10;&#10;FetchContent_MakeAvailable(nlohmann_json spdlog imgui glm entt magic_enum pugixml)&#10;&#10;find_package(SDL2 REQUIRED)&#10;&#10;file(GLOB_RECURSE SOURCES CONFIGURE_DEPENDS &quot;Core/*.cpp&quot; &quot;Core/*.hpp&quot;)&#10;&#10;# ImGui configuration&#10;FetchContent_GetProperties(imgui)&#10;if(NOT imgui_POPULATED)&#10;    FetchContent_Populate(imgui)&#10;endif()&#10;&#10;# ImGui sources&#10;set(IMGUI_SOURCES&#10;    ${imgui_SOURCE_DIR}/imgui.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_demo.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_draw.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_tables.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_widgets.cpp&#10;    ${imgui_SOURCE_DIR}/backends/imgui_impl_sdl2.cpp&#10;    ${imgui_SOURCE_DIR}/backends/imgui_impl_sdlrenderer2.cpp&#10;)&#10;&#10;add_executable(negentropy ${SOURCES} ${IMGUI_SOURCES})&#10;&#10;target_include_directories(negentropy PRIVATE&#10;    Core&#10;    ${imgui_SOURCE_DIR}&#10;    ${imgui_SOURCE_DIR}/backends&#10;)&#10;&#10;target_link_libraries(negentropy PRIVATE&#10;    SDL2::SDL2 &#10;    nlohmann_json::nlohmann_json &#10;    spdlog::spdlog&#10;    glm::glm&#10;    EnTT::EnTT&#10;    magic_enum::magic_enum&#10;    pugixml::pugixml&#10;)" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.16)&#10;project(negentropy LANGUAGES CXX)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;include(FetchContent)&#10;FetchContent_Declare(&#10;  nlohmann_json&#10;  GIT_REPOSITORY https://github.com/nlohmann/json.git&#10;  GIT_TAG v3.12.0&#10;)&#10;&#10;FetchContent_Declare(&#10;  spdlog&#10;  GIT_REPOSITORY https://github.com/gabime/spdlog.git&#10;  GIT_TAG v1.15.3&#10;)&#10;&#10;FetchContent_Declare(&#10;  imgui&#10;  GIT_REPOSITORY https://github.com/ocornut/imgui.git&#10;  GIT_TAG v1.92.1&#10;)&#10;&#10;FetchContent_Declare(&#10;  glm&#10;  GIT_REPOSITORY https://github.com/g-truc/glm.git&#10;  GIT_TAG 1.0.1&#10;)&#10;&#10;FetchContent_Declare(&#10;  entt&#10;  GIT_REPOSITORY https://github.com/skypjack/entt.git&#10;  GIT_TAG v3.15.0&#10;)&#10;&#10;FetchContent_Declare(&#10;  magic_enum&#10;  GIT_REPOSITORY https://github.com/Neargye/magic_enum.git&#10;  GIT_TAG v0.9.7&#10;)&#10;&#10;FetchContent_Declare(&#10;  pugixml&#10;  GIT_REPOSITORY https://github.com/zeux/pugixml.git&#10;  GIT_TAG v1.14&#10;)&#10;&#10;FetchContent_MakeAvailable(nlohmann_json spdlog imgui glm entt magic_enum pugixml)&#10;&#10;find_package(SDL2 REQUIRED)&#10;&#10;file(GLOB_RECURSE SOURCES CONFIGURE_DEPENDS &quot;Core/*.cpp&quot; &quot;Core/*.hpp&quot;)&#10;&#10;# ImGui configuration&#10;FetchContent_GetProperties(imgui)&#10;if(NOT imgui_POPULATED)&#10;    FetchContent_Populate(imgui)&#10;endif()&#10;&#10;# ImGui sources&#10;set(IMGUI_SOURCES&#10;    ${imgui_SOURCE_DIR}/imgui.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_demo.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_draw.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_tables.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_widgets.cpp&#10;    ${imgui_SOURCE_DIR}/backends/imgui_impl_sdl2.cpp&#10;    ${imgui_SOURCE_DIR}/backends/imgui_impl_sdlrenderer2.cpp&#10;)&#10;&#10;add_executable(negentropy ${SOURCES} ${IMGUI_SOURCES})&#10;&#10;target_include_directories(negentropy PRIVATE&#10;    Core&#10;    ${imgui_SOURCE_DIR}&#10;    ${imgui_SOURCE_DIR}/backends&#10;)&#10;&#10;target_compile_definitions(negentropy PRIVATE PROJECT_SOURCE_DIR=&quot;${CMAKE_SOURCE_DIR}&quot;)&#10;&#10;target_link_libraries(negentropy PRIVATE&#10;    SDL2::SDL2 &#10;    nlohmann_json::nlohmann_json &#10;    spdlog::spdlog&#10;    glm::glm&#10;    EnTT::EnTT&#10;    magic_enum::magic_enum&#10;    pugixml::pugixml&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Main/Application.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Main/Application.cpp" />
              <option name="originalContent" value="#include &quot;Application.hpp&quot;&#10;#include &quot;Renderer.hpp&quot;&#10;#include &quot;EventHandler.hpp&quot;&#10;#include &quot;DiagramData.hpp&quot;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;spdlog/spdlog.h&gt;&#10;#include &lt;imgui.h&gt;&#10;#include &lt;imgui_impl_sdl2.h&gt;&#10;#include &lt;imgui_impl_sdlrenderer2.h&gt;&#10;#include &lt;filesystem&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;&#10;namespace fs = std::filesystem;&#10;&#10;Application::Application() : m_eventHandler(std::make_unique&lt;EventHandler&gt;()), m_diagramData(std::make_unique&lt;DiagramData&gt;()) {&#10;    InitSDL();&#10;    CreateWindow();&#10;&#10;    if (!m_renderer.Initialize(m_window)) {&#10;        SDL_DestroyWindow(m_window);&#10;        SDL_Quit();&#10;        throw std::runtime_error(&quot;Failed to initialize renderer&quot;);&#10;    }&#10;&#10;    InitializeImGui();&#10;    &#10;    spdlog::info(&quot;Application initialized successfully&quot;);&#10;&#10;    RefreshWorkspaceFiles();&#10;    RenderFrame();&#10;    SDL_Delay(16);&#10;    SDL_ShowWindow(m_window);&#10;}&#10;&#10;Application::~Application() {&#10;    spdlog::info(&quot;Shutting down application...&quot;);&#10;    &#10;    ImGui_ImplSDLRenderer2_Shutdown();&#10;    ImGui_ImplSDL2_Shutdown();&#10;    ImGui::DestroyContext();&#10;&#10;    if (m_window) {&#10;        SDL_DestroyWindow(m_window);&#10;        m_window = nullptr;&#10;    }&#10;    &#10;    SDL_Quit();&#10;    spdlog::info(&quot;Application shutdown complete&quot;);&#10;}&#10;&#10;void Application::Run() {&#10;    while (m_running) {&#10;        ProcessEvents();&#10;        Update();&#10;        RenderFrame();&#10;    }&#10;}&#10;&#10;void Application::InitializeImGui() const {&#10;    IMGUI_CHECKVERSION();&#10;    ImGui::CreateContext();&#10;    ImGuiIO&amp; io = ImGui::GetIO();&#10;    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;&#10;    // io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;&#10;    &#10;    ImGui::StyleColorsDark();&#10;    &#10;    ImGui_ImplSDL2_InitForSDLRenderer(m_window, m_renderer.GetSDLRenderer());&#10;    ImGui_ImplSDLRenderer2_Init(m_renderer.GetSDLRenderer());&#10;&#10;    spdlog::info(&quot;ImGui initialized with SDL2 renderer&quot;);&#10;}&#10;&#10;void Application::ProcessEvents() noexcept {&#10;    SDL_Event event;&#10;    while (SDL_PollEvent(&amp;event)) {&#10;        ImGui_ImplSDL2_ProcessEvent(&amp;event);&#10;        &#10;        if (event.type == SDL_QUIT || (event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym == SDLK_ESCAPE)) {&#10;            m_running = false;&#10;            return;&#10;        }&#10;        &#10;        if (!ImGui::GetIO().WantCaptureMouse &amp;&amp; !ImGui::GetIO().WantCaptureKeyboard) {&#10;            m_eventHandler-&gt;HandleEvent(event, m_diagramData-&gt;GetCamera(), m_diagramData-&gt;GetBlocks());&#10;        }&#10;    }&#10;}&#10;&#10;void Application::Update() noexcept {&#10;}&#10;&#10;void Application::RenderFrame() noexcept {&#10;&#10;    ImGui_ImplSDLRenderer2_NewFrame();&#10;    ImGui_ImplSDL2_NewFrame();&#10;    ImGui::NewFrame();&#10;    &#10;    RenderUI();&#10;    &#10;    m_renderer.Clear();&#10;    m_renderer.DrawGrid(m_diagramData-&gt;GetCamera());&#10;    m_renderer.DrawBlocks(m_diagramData-&gt;GetBlocks(), m_diagramData-&gt;GetCamera());&#10;&#10;    ImGui::Render();&#10;    ImGui_ImplSDLRenderer2_RenderDrawData(ImGui::GetDrawData(), m_renderer.GetSDLRenderer());&#10;&#10;    m_renderer.Present();&#10;}&#10;&#10;void Application::RenderUI() noexcept {&#10;&#10;    if (ImGui::BeginMainMenuBar()) {&#10;        if (ImGui::BeginMenu(&quot;File&quot;)) {&#10;            if (ImGui::BeginMenu(&quot;Load&quot;)) {&#10;                for (const auto&amp; file : m_workspaceFiles) {&#10;                    if (ImGui::MenuItem(file.c_str())) {&#10;                        m_diagramData-&gt;Load(&quot;Workspace/&quot; + file);&#10;                    }&#10;                }&#10;                ImGui::EndMenu();&#10;            }&#10;            if (ImGui::MenuItem(&quot;Save&quot;)) {&#10;                m_diagramData-&gt;Save(&quot;Workspace/Default.xml&quot;);&#10;            }&#10;            ImGui::Separator();&#10;            if (ImGui::MenuItem(&quot;Exit&quot;, &quot;Alt+F4&quot;)) {&#10;                m_running = false;&#10;            }&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        if (ImGui::BeginMenu(&quot;Edit&quot;)) {&#10;            if (ImGui::MenuItem(&quot;Undo&quot;, &quot;Ctrl+Z&quot;)) {}&#10;            if (ImGui::MenuItem(&quot;Redo&quot;, &quot;Ctrl+Y&quot;)) {}&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        if (ImGui::BeginMenu(&quot;View&quot;)) {&#10;            ImGui::MenuItem(&quot;Properties&quot;, nullptr, &amp;m_showProperties);&#10;            ImGui::MenuItem(&quot;Demo&quot;, nullptr, &amp;m_showDemo);&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        ImGui::EndMainMenuBar();&#10;    }&#10;    &#10;    if (m_showProperties) {&#10;        RenderPropertiesPanel();&#10;    }&#10;    &#10;    if (m_showDemo) {&#10;        ImGui::ShowDemoWindow(&amp;m_showDemo);&#10;    }&#10;}&#10;&#10;void Application::RenderPropertiesPanel() noexcept {&#10;    ImGui::Begin(&quot;Properties&quot;, &amp;m_showProperties);&#10;    &#10;    auto&amp; blocks = m_diagramData-&gt;GetBlocks();&#10;    auto&amp; camera = m_diagramData-&gt;GetCamera();&#10;    &#10;    ImGui::Text(&quot;Camera Position: (%.1f, %.1f)&quot;, camera.position.x, camera.position.y);&#10;    ImGui::Text(&quot;Blocks Count: %zu&quot;, blocks.size());&#10;    &#10;    if (ImGui::Button(&quot;Add Block&quot;)) {&#10;        blocks.emplace_back();&#10;        auto&amp; newBlock = blocks.back();&#10;        newBlock.position = {100.0f + blocks.size() * 150.0f, 100.0f};&#10;        newBlock.label = &quot;Block &quot; + std::to_string(blocks.size());&#10;    }&#10;    &#10;    ImGui::Separator();&#10;    &#10;    for (size_t i = 0; i &lt; blocks.size(); ++i) {&#10;        auto&amp; block = blocks[i];&#10;        ImGui::PushID(static_cast&lt;int&gt;(i));&#10;        &#10;        if (ImGui::CollapsingHeader((&quot;Block &quot; + std::to_string(i + 1)).c_str())) {&#10;            char labelBuffer[256];&#10;            strncpy(labelBuffer, block.label.c_str(), sizeof(labelBuffer) - 1);&#10;            labelBuffer[sizeof(labelBuffer) - 1] = '\0';&#10;            if (ImGui::InputText(&quot;Label&quot;, labelBuffer, sizeof(labelBuffer))) {&#10;                block.label = labelBuffer;&#10;            }&#10;            ImGui::DragFloat2(&quot;Position&quot;, &amp;block.position.x, 1.0f);&#10;            ImGui::DragFloat2(&quot;Size&quot;, &amp;block.size.x, 1.0f, 10.0f, 500.0f);&#10;            ImGui::ColorEdit4(&quot;Color&quot;, &amp;block.color.x);&#10;            &#10;            const char* typeNames[] = {&quot;Start&quot;, &quot;Process&quot;, &quot;Decision&quot;, &quot;End&quot;};&#10;            int currentType = static_cast&lt;int&gt;(block.type);&#10;            if (ImGui::Combo(&quot;Type&quot;, &amp;currentType, typeNames, 4)) {&#10;                block.type = static_cast&lt;Diagram::BlockType&gt;(currentType);&#10;            }&#10;            &#10;            if (ImGui::Button(&quot;Delete&quot;)) {&#10;                blocks.erase(blocks.begin() + i);&#10;                ImGui::PopID();&#10;                break;&#10;            }&#10;        }&#10;        &#10;        ImGui::PopID();&#10;    }&#10;    &#10;    ImGui::End();&#10;}&#10;&#10;void Application::RefreshWorkspaceFiles() {&#10;    m_workspaceFiles.clear();&#10;    const std::string path = &quot;Workspace&quot;;&#10;    for (const auto &amp; entry : fs::directory_iterator(path)) {&#10;        if (entry.is_regular_file() &amp;&amp; entry.path().extension() == &quot;.xml&quot;) {&#10;            m_workspaceFiles.push_back(entry.path().filename().string());&#10;        }&#10;    }&#10;}&#10;&#10;void Application::InitSDL() {&#10;    spdlog::info(&quot;Initializing SDL...&quot;);&#10;    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS) != 0)&#10;        throw std::runtime_error(&quot;SDL_Init error: &quot; + std::string(SDL_GetError()));&#10;&#10;    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, &quot;0&quot;);&#10;    SDL_SetHint(SDL_HINT_RENDER_VSYNC, &quot;0&quot;);&#10;    SDL_SetHint(SDL_HINT_RENDER_DRIVER, &quot;opengl&quot;);&#10;    SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, &quot;0&quot;);&#10;}&#10;&#10;void Application::CreateWindow() {&#10;    spdlog::info(&quot;Creating window...&quot;);&#10;    int displayIndex = 0;&#10;    int mouseX, mouseY;&#10;    SDL_GetGlobalMouseState(&amp;mouseX, &amp;mouseY);&#10;    int numDisplays = SDL_GetNumVideoDisplays();&#10;&#10;    for (int i = 0; i &lt; numDisplays; i++) {&#10;        SDL_Rect displayBounds;&#10;        if (SDL_GetDisplayBounds(i, &amp;displayBounds) == 0 &amp;&amp;&#10;            mouseX &gt;= displayBounds.x &amp;&amp; mouseX &lt; displayBounds.x + displayBounds.w &amp;&amp;&#10;            mouseY &gt;= displayBounds.y &amp;&amp; mouseY &lt; displayBounds.y + displayBounds.h) {&#10;            displayIndex = i;&#10;            break;&#10;        }&#10;    }&#10;&#10;    m_window = SDL_CreateWindow(&quot;Negentropy - Diagram Editor&quot;,&#10;                                SDL_WINDOWPOS_CENTERED_DISPLAY(displayIndex),&#10;                                SDL_WINDOWPOS_CENTERED_DISPLAY(displayIndex), 1280, 720,&#10;                                SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);&#10;    if (!m_window) {&#10;        SDL_Quit();&#10;        throw std::runtime_error(&quot;SDL_CreateWindow error: &quot; + std::string(SDL_GetError()));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;Application.hpp&quot;&#10;#include &quot;Renderer.hpp&quot;&#10;#include &quot;EventHandler.hpp&quot;&#10;#include &quot;DiagramData.hpp&quot;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;spdlog/spdlog.h&gt;&#10;#include &lt;imgui.h&gt;&#10;#include &lt;imgui_impl_sdl2.h&gt;&#10;#include &lt;imgui_impl_sdlrenderer2.h&gt;&#10;#include &lt;filesystem&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &quot;../Utils/Path.hpp&quot;&#10;&#10;namespace fs = std::filesystem;&#10;&#10;Application::Application() : m_eventHandler(std::make_unique&lt;EventHandler&gt;()), m_diagramData(std::make_unique&lt;DiagramData&gt;()) {&#10;    InitSDL();&#10;    CreateWindow();&#10;&#10;    if (!m_renderer.Initialize(m_window)) {&#10;        SDL_DestroyWindow(m_window);&#10;        SDL_Quit();&#10;        throw std::runtime_error(&quot;Failed to initialize renderer&quot;);&#10;    }&#10;&#10;    InitializeImGui();&#10;    &#10;    spdlog::info(&quot;Application initialized successfully&quot;);&#10;&#10;    RefreshWorkspaceFiles();&#10;    RenderFrame();&#10;    SDL_Delay(16);&#10;    SDL_ShowWindow(m_window);&#10;}&#10;&#10;Application::~Application() {&#10;    spdlog::info(&quot;Shutting down application...&quot;);&#10;    &#10;    ImGui_ImplSDLRenderer2_Shutdown();&#10;    ImGui_ImplSDL2_Shutdown();&#10;    ImGui::DestroyContext();&#10;&#10;    if (m_window) {&#10;        SDL_DestroyWindow(m_window);&#10;        m_window = nullptr;&#10;    }&#10;    &#10;    SDL_Quit();&#10;    spdlog::info(&quot;Application shutdown complete&quot;);&#10;}&#10;&#10;void Application::Run() {&#10;    while (m_running) {&#10;        ProcessEvents();&#10;        Update();&#10;        RenderFrame();&#10;    }&#10;}&#10;&#10;void Application::InitializeImGui() const {&#10;    IMGUI_CHECKVERSION();&#10;    ImGui::CreateContext();&#10;    ImGuiIO&amp; io = ImGui::GetIO();&#10;    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;&#10;    // io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;&#10;    &#10;    ImGui::StyleColorsDark();&#10;    &#10;    ImGui_ImplSDL2_InitForSDLRenderer(m_window, m_renderer.GetSDLRenderer());&#10;    ImGui_ImplSDLRenderer2_Init(m_renderer.GetSDLRenderer());&#10;&#10;    spdlog::info(&quot;ImGui initialized with SDL2 renderer&quot;);&#10;}&#10;&#10;void Application::ProcessEvents() noexcept {&#10;    SDL_Event event;&#10;    while (SDL_PollEvent(&amp;event)) {&#10;        ImGui_ImplSDL2_ProcessEvent(&amp;event);&#10;        &#10;        if (event.type == SDL_QUIT || (event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym == SDLK_ESCAPE)) {&#10;            m_running = false;&#10;            return;&#10;        }&#10;        &#10;        if (!ImGui::GetIO().WantCaptureMouse &amp;&amp; !ImGui::GetIO().WantCaptureKeyboard) {&#10;            m_eventHandler-&gt;HandleEvent(event, m_diagramData-&gt;GetCamera(), m_diagramData-&gt;GetBlocks());&#10;        }&#10;    }&#10;}&#10;&#10;void Application::Update() noexcept {&#10;}&#10;&#10;void Application::RenderFrame() noexcept {&#10;&#10;    ImGui_ImplSDLRenderer2_NewFrame();&#10;    ImGui_ImplSDL2_NewFrame();&#10;    ImGui::NewFrame();&#10;    &#10;    RenderUI();&#10;    &#10;    m_renderer.Clear();&#10;    m_renderer.DrawGrid(m_diagramData-&gt;GetCamera());&#10;    m_renderer.DrawBlocks(m_diagramData-&gt;GetBlocks(), m_diagramData-&gt;GetCamera());&#10;&#10;    ImGui::Render();&#10;    ImGui_ImplSDLRenderer2_RenderDrawData(ImGui::GetDrawData(), m_renderer.GetSDLRenderer());&#10;&#10;    m_renderer.Present();&#10;}&#10;&#10;void Application::RenderUI() noexcept {&#10;&#10;    if (ImGui::BeginMainMenuBar()) {&#10;        if (ImGui::BeginMenu(&quot;File&quot;)) {&#10;            if (ImGui::BeginMenu(&quot;Load&quot;)) {&#10;                for (const auto&amp; file : m_workspaceFiles) {&#10;                    if (ImGui::MenuItem(file.c_str())) {&#10;                        m_diagramData-&gt;Load((Utils::GetWorkspacePath() / file).string());&#10;                    }&#10;                }&#10;                ImGui::EndMenu();&#10;            }&#10;            if (ImGui::MenuItem(&quot;Save&quot;)) {&#10;                m_diagramData-&gt;Save((Utils::GetWorkspacePath() / &quot;Default.xml&quot;).string());&#10;            }&#10;            ImGui::Separator();&#10;            if (ImGui::MenuItem(&quot;Exit&quot;, &quot;Alt+F4&quot;)) {&#10;                m_running = false;&#10;            }&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        if (ImGui::BeginMenu(&quot;Edit&quot;)) {&#10;            if (ImGui::MenuItem(&quot;Undo&quot;, &quot;Ctrl+Z&quot;)) {}&#10;            if (ImGui::MenuItem(&quot;Redo&quot;, &quot;Ctrl+Y&quot;)) {}&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        if (ImGui::BeginMenu(&quot;View&quot;)) {&#10;            ImGui::MenuItem(&quot;Properties&quot;, nullptr, &amp;m_showProperties);&#10;            ImGui::MenuItem(&quot;Demo&quot;, nullptr, &amp;m_showDemo);&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        ImGui::EndMainMenuBar();&#10;    }&#10;    &#10;    if (m_showProperties) {&#10;        RenderPropertiesPanel();&#10;    }&#10;    &#10;    if (m_showDemo) {&#10;        ImGui::ShowDemoWindow(&amp;m_showDemo);&#10;    }&#10;}&#10;&#10;void Application::RenderPropertiesPanel() noexcept {&#10;    ImGui::Begin(&quot;Properties&quot;, &amp;m_showProperties);&#10;    &#10;    auto&amp; blocks = m_diagramData-&gt;GetBlocks();&#10;    auto&amp; camera = m_diagramData-&gt;GetCamera();&#10;    &#10;    ImGui::Text(&quot;Camera Position: (%.1f, %.1f)&quot;, camera.position.x, camera.position.y);&#10;    ImGui::Text(&quot;Blocks Count: %zu&quot;, blocks.size());&#10;    &#10;    if (ImGui::Button(&quot;Add Block&quot;)) {&#10;        blocks.emplace_back();&#10;        auto&amp; newBlock = blocks.back();&#10;        newBlock.position = {100.0f + blocks.size() * 150.0f, 100.0f};&#10;        newBlock.label = &quot;Block &quot; + std::to_string(blocks.size());&#10;    }&#10;    &#10;    ImGui::Separator();&#10;    &#10;    for (size_t i = 0; i &lt; blocks.size(); ++i) {&#10;        auto&amp; block = blocks[i];&#10;        ImGui::PushID(static_cast&lt;int&gt;(i));&#10;        &#10;        if (ImGui::CollapsingHeader((&quot;Block &quot; + std::to_string(i + 1)).c_str())) {&#10;            char labelBuffer[256];&#10;            strncpy(labelBuffer, block.label.c_str(), sizeof(labelBuffer) - 1);&#10;            labelBuffer[sizeof(labelBuffer) - 1] = '\0';&#10;            if (ImGui::InputText(&quot;Label&quot;, labelBuffer, sizeof(labelBuffer))) {&#10;                block.label = labelBuffer;&#10;            }&#10;            ImGui::DragFloat2(&quot;Position&quot;, &amp;block.position.x, 1.0f);&#10;            ImGui::DragFloat2(&quot;Size&quot;, &amp;block.size.x, 1.0f, 10.0f, 500.0f);&#10;            ImGui::ColorEdit4(&quot;Color&quot;, &amp;block.color.x);&#10;            &#10;            const char* typeNames[] = {&quot;Start&quot;, &quot;Process&quot;, &quot;Decision&quot;, &quot;End&quot;};&#10;            int currentType = static_cast&lt;int&gt;(block.type);&#10;            if (ImGui::Combo(&quot;Type&quot;, &amp;currentType, typeNames, 4)) {&#10;                block.type = static_cast&lt;Diagram::BlockType&gt;(currentType);&#10;            }&#10;            &#10;            if (ImGui::Button(&quot;Delete&quot;)) {&#10;                blocks.erase(blocks.begin() + i);&#10;                ImGui::PopID();&#10;                break;&#10;            }&#10;        }&#10;        &#10;        ImGui::PopID();&#10;    }&#10;    &#10;    ImGui::End();&#10;}&#10;&#10;void Application::RefreshWorkspaceFiles() {&#10;    m_workspaceFiles.clear();&#10;    const auto path = Utils::GetWorkspacePath();&#10;    for (const auto &amp; entry : fs::directory_iterator(path)) {&#10;        if (entry.is_regular_file() &amp;&amp; entry.path().extension() == &quot;.xml&quot;) {&#10;            m_workspaceFiles.push_back(entry.path().filename().string());&#10;        }&#10;    }&#10;}&#10;&#10;void Application::InitSDL() {&#10;    spdlog::info(&quot;Initializing SDL...&quot;);&#10;    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS) != 0)&#10;        throw std::runtime_error(&quot;SDL_Init error: &quot; + std::string(SDL_GetError()));&#10;&#10;    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, &quot;0&quot;);&#10;    SDL_SetHint(SDL_HINT_RENDER_VSYNC, &quot;0&quot;);&#10;    SDL_SetHint(SDL_HINT_RENDER_DRIVER, &quot;opengl&quot;);&#10;    SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, &quot;0&quot;);&#10;}&#10;&#10;void Application::CreateWindow() {&#10;    spdlog::info(&quot;Creating window...&quot;);&#10;    int displayIndex = 0;&#10;    int mouseX, mouseY;&#10;    SDL_GetGlobalMouseState(&amp;mouseX, &amp;mouseY);&#10;    int numDisplays = SDL_GetNumVideoDisplays();&#10;&#10;    for (int i = 0; i &lt; numDisplays; i++) {&#10;        SDL_Rect displayBounds;&#10;        if (SDL_GetDisplayBounds(i, &amp;displayBounds) == 0 &amp;&amp;&#10;            mouseX &gt;= displayBounds.x &amp;&amp; mouseX &lt; displayBounds.x + displayBounds.w &amp;&amp;&#10;            mouseY &gt;= displayBounds.y &amp;&amp; mouseY &lt; displayBounds.y + displayBounds.h) {&#10;            displayIndex = i;&#10;            break;&#10;        }&#10;    }&#10;&#10;    m_window = SDL_CreateWindow(&quot;Negentropy - Diagram Editor&quot;,&#10;                                SDL_WINDOWPOS_CENTERED_DISPLAY(displayIndex),&#10;                                SDL_WINDOWPOS_CENTERED_DISPLAY(displayIndex), 1280, 720,&#10;                                SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);&#10;    if (!m_window) {&#10;        SDL_Quit();&#10;        throw std::runtime_error(&quot;SDL_CreateWindow error: &quot; + std::string(SDL_GetError()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Main/Application.hpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Main/Application.hpp" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;SDL.h&gt;&#10;#include &lt;memory&gt;&#10;#include &quot;Renderer.hpp&quot;&#10;#include &quot;EventHandler.hpp&quot;&#10;#include &quot;DiagramData.hpp&quot;&#10;&#10;class Application {&#10;public:&#10;    Application();&#10;    ~Application();&#10;&#10;    Application(const Application&amp;) = delete;&#10;    Application&amp; operator=(const Application&amp;) = delete;&#10;    Application(Application&amp;&amp;) = delete;&#10;    Application&amp; operator=(Application&amp;&amp;) = delete;&#10;&#10;    void Run();&#10;&#10;private:&#10;    void InitializeImGui() const;&#10;    void ProcessEvents() noexcept;&#10;    void Update() noexcept;&#10;    void RenderFrame() noexcept;&#10;    void RenderUI() noexcept;&#10;    void RenderPropertiesPanel() noexcept;&#10;&#10;    static void InitSDL();&#10;    void CreateWindow();&#10;&#10;    bool m_running = true;&#10;    SDL_Window* m_window = nullptr;&#10;    Renderer m_renderer;&#10;    std::unique_ptr&lt;EventHandler&gt; m_eventHandler;&#10;    std::unique_ptr&lt;DiagramData&gt; m_diagramData;&#10;&#10;    bool m_showProperties = true;&#10;    bool m_showDemo = false;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;SDL.h&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &quot;Renderer.hpp&quot;&#10;#include &quot;EventHandler.hpp&quot;&#10;#include &quot;DiagramData.hpp&quot;&#10;&#10;class Application {&#10;public:&#10;    Application();&#10;    ~Application();&#10;&#10;    Application(const Application&amp;) = delete;&#10;    Application&amp; operator=(const Application&amp;) = delete;&#10;    Application(Application&amp;&amp;) = delete;&#10;    Application&amp; operator=(Application&amp;&amp;) = delete;&#10;&#10;    void Run();&#10;&#10;private:&#10;    void InitializeImGui() const;&#10;    void ProcessEvents() noexcept;&#10;    void Update() noexcept;&#10;    void RenderFrame() noexcept;&#10;    void RenderUI() noexcept;&#10;    void RenderPropertiesPanel() noexcept;&#10;    void RefreshWorkspaceFiles();&#10;&#10;    static void InitSDL();&#10;    void CreateWindow();&#10;&#10;    bool m_running = true;&#10;    SDL_Window* m_window = nullptr;&#10;    Renderer m_renderer;&#10;    std::unique_ptr&lt;EventHandler&gt; m_eventHandler;&#10;    std::unique_ptr&lt;DiagramData&gt; m_diagramData;&#10;&#10;    std::vector&lt;std::string&gt; m_workspaceFiles;&#10;    bool m_showProperties = true;&#10;    bool m_showDemo = false;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Main/DiagramData.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Main/DiagramData.cpp" />
              <option name="originalContent" value="#include &quot;DiagramData.hpp&quot;&#10;#include &lt;pugixml.hpp&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;magic_enum/magic_enum.hpp&gt;&#10;&#10;DiagramData::DiagramData() noexcept {&#10;    Load(&quot;Workspace/Default.xml&quot;);&#10;}&#10;&#10;void DiagramData::Load(const std::string&amp; filePath) {&#10;    pugi::xml_document doc;&#10;    pugi::xml_parse_result result = doc.load_file(filePath.c_str());&#10;    if (!result) {&#10;        std::cerr &lt;&lt; &quot;Error loading file: &quot; &lt;&lt; result.description() &lt;&lt; std::endl;&#10;        return;&#10;    }&#10;&#10;    m_blocks.clear();&#10;    auto diagram = doc.child(&quot;diagram&quot;);&#10;    if (!diagram) return;&#10;&#10;    auto cameraNode = diagram.child(&quot;camera&quot;).child(&quot;position&quot;);&#10;    if (cameraNode) {&#10;        m_camera.position.x = cameraNode.attribute(&quot;x&quot;).as_float();&#10;        m_camera.position.y = cameraNode.attribute(&quot;y&quot;).as_float();&#10;    }&#10;&#10;    for (pugi::xml_node blockNode : diagram.child(&quot;blocks&quot;).children(&quot;block&quot;)) {&#10;        Diagram::Block block;&#10;        block.type = magic_enum::enum_cast&lt;Diagram::BlockType&gt;(blockNode.attribute(&quot;type&quot;).as_string()).value_or(Diagram::BlockType::Process);&#10;        block.position.x = blockNode.child(&quot;position&quot;).attribute(&quot;x&quot;).as_float();&#10;        block.position.y = blockNode.child(&quot;position&quot;).attribute(&quot;y&quot;).as_float();&#10;        block.size.x = blockNode.child(&quot;size&quot;).attribute(&quot;x&quot;).as_float();&#10;        block.size.y = blockNode.child(&quot;size&quot;).attribute(&quot;y&quot;).as_float();&#10;        block.label = blockNode.child(&quot;label&quot;).text().as_string();&#10;        block.color.r = blockNode.child(&quot;color&quot;).attribute(&quot;r&quot;).as_float();&#10;        block.color.g = blockNode.child(&quot;color&quot;).attribute(&quot;g&quot;).as_float();&#10;        block.color.b = blockNode.child(&quot;color&quot;).attribute(&quot;b&quot;).as_float();&#10;        block.color.a = blockNode.child(&quot;color&quot;).attribute(&quot;a&quot;).as_float();&#10;        m_blocks.push_back(block);&#10;    }&#10;}&#10;&#10;void DiagramData::Save(const std::string&amp; filePath) {&#10;    pugi::xml_document doc;&#10;    auto diagram = doc.append_child(&quot;diagram&quot;);&#10;&#10;    auto cameraNode = diagram.append_child(&quot;camera&quot;).append_child(&quot;position&quot;);&#10;    cameraNode.append_attribute(&quot;x&quot;).set_value(m_camera.position.x);&#10;    cameraNode.append_attribute(&quot;y&quot;).set_value(m_camera.position.y);&#10;&#10;    auto blocksNode = diagram.append_child(&quot;blocks&quot;);&#10;    for (const auto&amp; block : m_blocks) {&#10;        auto blockNode = blocksNode.append_child(&quot;block&quot;);&#10;        blockNode.append_attribute(&quot;type&quot;).set_value(magic_enum::enum_name(block.type).data());&#10;        blockNode.append_child(&quot;position&quot;).append_attribute(&quot;x&quot;).set_value(block.position.x);&#10;        blockNode.child(&quot;position&quot;).append_attribute(&quot;y&quot;).set_value(block.position.y);&#10;        blockNode.append_child(&quot;size&quot;).append_attribute(&quot;x&quot;).set_value(block.size.x);&#10;        blockNode.child(&quot;size&quot;).append_attribute(&quot;y&quot;).set_value(block.size.y);&#10;        blockNode.append_child(&quot;label&quot;).text().set(block.label.c_str());&#10;        auto colorNode = blockNode.append_child(&quot;color&quot;);&#10;        colorNode.append_attribute(&quot;r&quot;).set_value(block.color.r);&#10;        colorNode.append_attribute(&quot;g&quot;).set_value(block.color.g);&#10;        colorNode.append_attribute(&quot;b&quot;).set_value(block.color.b);&#10;        colorNode.append_attribute(&quot;a&quot;).set_value(block.color.a);&#10;    }&#10;    doc.save_file(filePath.c_str());&#10;}&#10;&#10;" />
              <option name="updatedContent" value="#include &quot;DiagramData.hpp&quot;&#10;#include &lt;pugixml.hpp&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;magic_enum/magic_enum.hpp&gt;&#10;#include &quot;../Utils/Path.hpp&quot;&#10;&#10;DiagramData::DiagramData() noexcept {&#10;    Load((Utils::GetWorkspacePath() / &quot;Default.xml&quot;).string());&#10;}&#10;&#10;void DiagramData::Load(const std::string&amp; filePath) {&#10;    pugi::xml_document doc;&#10;    pugi::xml_parse_result result = doc.load_file(filePath.c_str());&#10;    if (!result) {&#10;        std::cerr &lt;&lt; &quot;Error loading file: &quot; &lt;&lt; result.description() &lt;&lt; std::endl;&#10;        return;&#10;    }&#10;&#10;    m_blocks.clear();&#10;    auto diagram = doc.child(&quot;diagram&quot;);&#10;    if (!diagram) return;&#10;&#10;    auto cameraNode = diagram.child(&quot;camera&quot;).child(&quot;position&quot;);&#10;    if (cameraNode) {&#10;        m_camera.position.x = cameraNode.attribute(&quot;x&quot;).as_float();&#10;        m_camera.position.y = cameraNode.attribute(&quot;y&quot;).as_float();&#10;    }&#10;&#10;    for (pugi::xml_node blockNode : diagram.child(&quot;blocks&quot;).children(&quot;block&quot;)) {&#10;        Diagram::Block block;&#10;        block.type = magic_enum::enum_cast&lt;Diagram::BlockType&gt;(blockNode.attribute(&quot;type&quot;).as_string()).value_or(Diagram::BlockType::Process);&#10;        block.position.x = blockNode.child(&quot;position&quot;).attribute(&quot;x&quot;).as_float();&#10;        block.position.y = blockNode.child(&quot;position&quot;).attribute(&quot;y&quot;).as_float();&#10;        block.size.x = blockNode.child(&quot;size&quot;).attribute(&quot;x&quot;).as_float();&#10;        block.size.y = blockNode.child(&quot;size&quot;).attribute(&quot;y&quot;).as_float();&#10;        block.label = blockNode.child(&quot;label&quot;).text().as_string();&#10;        block.color.r = blockNode.child(&quot;color&quot;).attribute(&quot;r&quot;).as_float();&#10;        block.color.g = blockNode.child(&quot;color&quot;).attribute(&quot;g&quot;).as_float();&#10;        block.color.b = blockNode.child(&quot;color&quot;).attribute(&quot;b&quot;).as_float();&#10;        block.color.a = blockNode.child(&quot;color&quot;).attribute(&quot;a&quot;).as_float();&#10;        m_blocks.push_back(block);&#10;    }&#10;}&#10;&#10;void DiagramData::Save(const std::string&amp; filePath) {&#10;    pugi::xml_document doc;&#10;    auto diagram = doc.append_child(&quot;diagram&quot;);&#10;&#10;    auto cameraNode = diagram.append_child(&quot;camera&quot;).append_child(&quot;position&quot;);&#10;    cameraNode.append_attribute(&quot;x&quot;).set_value(m_camera.position.x);&#10;    cameraNode.append_attribute(&quot;y&quot;).set_value(m_camera.position.y);&#10;&#10;    auto blocksNode = diagram.append_child(&quot;blocks&quot;);&#10;    for (const auto&amp; block : m_blocks) {&#10;        auto blockNode = blocksNode.append_child(&quot;block&quot;);&#10;        blockNode.append_attribute(&quot;type&quot;).set_value(magic_enum::enum_name(block.type).data());&#10;        blockNode.append_child(&quot;position&quot;).append_attribute(&quot;x&quot;).set_value(block.position.x);&#10;        blockNode.child(&quot;position&quot;).append_attribute(&quot;y&quot;).set_value(block.position.y);&#10;        blockNode.append_child(&quot;size&quot;).append_attribute(&quot;x&quot;).set_value(block.size.x);&#10;        blockNode.child(&quot;size&quot;).append_attribute(&quot;y&quot;).set_value(block.size.y);&#10;        blockNode.append_child(&quot;label&quot;).text().set(block.label.c_str());&#10;        auto colorNode = blockNode.append_child(&quot;color&quot;);&#10;        colorNode.append_attribute(&quot;r&quot;).set_value(block.color.r);&#10;        colorNode.append_attribute(&quot;g&quot;).set_value(block.color.g);&#10;        colorNode.append_attribute(&quot;b&quot;).set_value(block.color.b);&#10;        colorNode.append_attribute(&quot;a&quot;).set_value(block.color.a);&#10;    }&#10;    doc.save_file(filePath.c_str());&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Main/DiagramData.hpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Main/DiagramData.hpp" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &quot;../Diagram/Block.hpp&quot;&#10;#include &quot;../Diagram/Camera.hpp&quot;&#10;&#10;class DiagramData {&#10;public:&#10;    DiagramData() noexcept {&#10;        m_blocks = {&#10;            {{100.0f, 100.0f}, {120.0f, 60.0f}, &quot;Start&quot;, Diagram::BlockType::Start, {0.2f, 0.8f, 0.2f, 1.0f}},&#10;            {{320.0f, 180.0f}, {140.0f, 60.0f}, &quot;Process&quot;, Diagram::BlockType::Process, {0.35f, 0.47f, 0.78f, 1.0f}},&#10;            {{560.0f, 120.0f}, {120.0f, 60.0f}, &quot;End&quot;, Diagram::BlockType::End, {0.8f, 0.2f, 0.2f, 1.0f}}&#10;        };&#10;    }&#10;&#10;    DiagramData(const DiagramData&amp;) = delete;&#10;    DiagramData&amp; operator=(const DiagramData&amp;) = delete;&#10;    DiagramData(DiagramData&amp;&amp;) = delete;&#10;    DiagramData&amp; operator=(DiagramData&amp;&amp;) = delete;&#10;&#10;    [[nodiscard]] const std::vector&lt;Diagram::Block&gt;&amp; GetBlocks() const noexcept { return m_blocks; }&#10;    [[nodiscard]] std::vector&lt;Diagram::Block&gt;&amp; GetBlocks() noexcept { return m_blocks; }&#10;&#10;    [[nodiscard]] const Diagram::Camera&amp; GetCamera() const noexcept { return m_camera; }&#10;    [[nodiscard]] Diagram::Camera&amp; GetCamera() noexcept { return m_camera; }&#10;&#10;private:&#10;    std::vector&lt;Diagram::Block&gt; m_blocks;&#10;    Diagram::Camera m_camera;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &quot;../Diagram/Block.hpp&quot;&#10;#include &quot;../Diagram/Camera.hpp&quot;&#10;&#10;class DiagramData {&#10;public:&#10;    DiagramData() noexcept;&#10;&#10;    DiagramData(const DiagramData&amp;) = delete;&#10;    DiagramData&amp; operator=(const DiagramData&amp;) = delete;&#10;    DiagramData(DiagramData&amp;&amp;) = delete;&#10;    DiagramData&amp; operator=(DiagramData&amp;&amp;) = delete;&#10;&#10;    void Load(const std::string&amp; filePath);&#10;    void Save(const std::string&amp; filePath);&#10;&#10;    [[nodiscard]] const std::vector&lt;Diagram::Block&gt;&amp; GetBlocks() const noexcept { return m_blocks; }&#10;    [[nodiscard]] std::vector&lt;Diagram::Block&gt;&amp; GetBlocks() noexcept { return m_blocks; }&#10;&#10;    [[nodiscard]] const Diagram::Camera&amp; GetCamera() const noexcept { return m_camera; }&#10;    [[nodiscard]] Diagram::Camera&amp; GetCamera() noexcept { return m_camera; }&#10;&#10;private:&#10;    std::vector&lt;Diagram::Block&gt; m_blocks;&#10;    Diagram::Camera m_camera;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Utils/Path.hpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Utils/Path.hpp" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;filesystem&gt;&#10;#include &lt;string&gt;&#10;&#10;#ifndef PROJECT_SOURCE_DIR&#10;#define PROJECT_SOURCE_DIR &quot;.&quot;&#10;#endif&#10;&#10;namespace Utils {&#10;    inline std::filesystem::path GetWorkspacePath() {&#10;        return std::filesystem::path(PROJECT_SOURCE_DIR) / &quot;Workspace&quot;;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Workspace/Default.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Workspace/Default.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;diagram&gt;&#10;    &lt;camera&gt;&#10;        &lt;position x=&quot;0.0&quot; y=&quot;0.0&quot; /&gt;&#10;    &lt;/camera&gt;&#10;    &lt;blocks&gt;&#10;        &lt;block type=&quot;Start&quot;&gt;&#10;            &lt;position x=&quot;50.0&quot; y=&quot;50.0&quot; /&gt;&#10;            &lt;size x=&quot;120.0&quot; y=&quot;60.0&quot; /&gt;&#10;            &lt;label&gt;Start&lt;/label&gt;&#10;            &lt;color r=&quot;0.35&quot; g=&quot;0.47&quot; b=&quot;0.78&quot; a=&quot;1.0&quot; /&gt;&#10;        &lt;/block&gt;&#10;        &lt;block type=&quot;Process&quot;&gt;&#10;            &lt;position x=&quot;250.0&quot; y=&quot;150.0&quot; /&gt;&#10;            &lt;size x=&quot;120.0&quot; y=&quot;60.0&quot; /&gt;&#10;            &lt;label&gt;Some Action&lt;/label&gt;&#10;            &lt;color r=&quot;0.35&quot; g=&quot;0.47&quot; b=&quot;0.78&quot; a=&quot;1.0&quot; /&gt;&#10;        &lt;/block&gt;&#10;        &lt;block type=&quot;Decision&quot;&gt;&#10;            &lt;position x=&quot;50.0&quot; y=&quot;250.0&quot; /&gt;&#10;            &lt;size x=&quot;120.0&quot; y=&quot;60.0&quot; /&gt;&#10;            &lt;label&gt;Is it good?&lt;/label&gt;&#10;            &lt;color r=&quot;0.35&quot; g=&quot;0.47&quot; b=&quot;0.78&quot; a=&quot;1.0&quot; /&gt;&#10;        &lt;/block&gt;&#10;        &lt;block type=&quot;End&quot;&gt;&#10;            &lt;position x=&quot;250.0&quot; y=&quot;350.0&quot; /&gt;&#10;            &lt;size x=&quot;120.0&quot; y=&quot;60.0&quot; /&gt;&#10;            &lt;label&gt;End&lt;/label&gt;&#10;            &lt;color r=&quot;0.35&quot; g=&quot;0.47&quot; b=&quot;0.78&quot; a=&quot;1.0&quot; /&gt;&#10;        &lt;/block&gt;&#10;    &lt;/blocks&gt;&#10;&lt;/diagram&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>