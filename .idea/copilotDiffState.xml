<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Core/Diagram/Component.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Diagram/Component.cpp" />
              <option name="originalContent" value="#include &quot;Component.hpp&quot;&#10;#include &quot;Block.hpp&quot;&#10;#include &lt;imgui.h&gt;&#10;#include &lt;algorithm&gt;&#10;&#10;namespace Diagram {&#10;    ComponentBase* ComponentBase::s_selected = nullptr;&#10;&#10;    void ComponentBase::RenderComponentTree(std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        if (!ImGui::Begin(&quot;Component Tree&quot;)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        auto hierarchy = BuildHierarchy(components);&#10;        if (hierarchy) {&#10;            RenderTreeNode(*hierarchy, &amp;components);&#10;        }&#10;&#10;        ImGui::End();&#10;    }&#10;&#10;    void ComponentBase::RenderComponentEditor() noexcept {&#10;        if (!ImGui::Begin(&quot;Component Editor&quot;, nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (!s_selected) {&#10;            ImGui::TextDisabled(&quot;No component selected&quot;);&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (auto* block = dynamic_cast&lt;Block*&gt;(s_selected)) {&#10;            block-&gt;RenderUI(0);&#10;        } else {&#10;            ImGui::TextDisabled(&quot;Unknown component type&quot;);&#10;        }&#10;&#10;        ImGui::End();&#10;    }&#10;&#10;    void ComponentBase::RenderTreeNode(const ComponentBase::TreeNode&amp; node, std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;* components) noexcept {&#10;        ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_DefaultOpen;&#10;        &#10;        if (node.children.empty()) {&#10;            flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;&#10;        }&#10;        &#10;        if (s_selected == node.component) {&#10;            flags |= ImGuiTreeNodeFlags_Selected;&#10;        }&#10;&#10;        bool nodeOpen = ImGui::TreeNodeEx(node.name.c_str(), flags);&#10;        &#10;        if (ImGui::IsItemClicked() &amp;&amp; node.component) {&#10;            Select(node.component);&#10;        }&#10;&#10;        // Drag &amp; drop only for components (not for root node)&#10;        if (node.component) {&#10;            if (ImGui::BeginDragDropSource()) {&#10;                ImGui::SetDragDropPayload(&quot;COMPONENT_DND&quot;, &amp;node.component, sizeof(void*));&#10;                ImGui::Text(&quot;Moving: %s&quot;, node.name.c_str());&#10;                ImGui::EndDragDropSource();&#10;            }&#10;        }&#10;&#10;        if (nodeOpen &amp;&amp; !node.children.empty()) {&#10;            for (auto&amp; child : node.children) {&#10;                RenderTreeNode(*child, components);&#10;                &#10;                // Drop target for reorder&#10;                if (child-&gt;component &amp;&amp; ImGui::BeginDragDropTarget()) {&#10;                    if (const auto* payload = ImGui::AcceptDragDropPayload(&quot;COMPONENT_DND&quot;)) {&#10;                        auto* draggedComp = *static_cast&lt;ComponentBase**&gt;(payload-&gt;Data);&#10;                        if (components &amp;&amp; draggedComp != child-&gt;component) {&#10;                            auto draggedIt = std::find_if(components-&gt;begin(), components-&gt;end(),&#10;                                [draggedComp](const auto&amp; c) { return c.get() == draggedComp; });&#10;                            auto targetIt = std::find_if(components-&gt;begin(), components-&gt;end(),&#10;                                [&amp;child](const auto&amp; c) { return c.get() == child-&gt;component; });&#10;                            &#10;                            if (draggedIt != components-&gt;end() &amp;&amp; targetIt != components-&gt;end()) {&#10;                                std::iter_swap(draggedIt, targetIt);&#10;                            }&#10;                        }&#10;                    }&#10;                    ImGui::EndDragDropTarget();&#10;                }&#10;            }&#10;            ImGui::TreePop();&#10;        }&#10;    }&#10;&#10;    std::unique_ptr&lt;ComponentBase::TreeNode&gt; ComponentBase::BuildHierarchy(const std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        auto root = std::make_unique&lt;TreeNode&gt;(&quot;Scene&quot;);&#10;        &#10;        for (const auto&amp; component : components) {&#10;            auto componentNode = std::make_unique&lt;TreeNode&gt;(&#10;                component-&gt;GetDisplayName(),&#10;                component.get()&#10;            );&#10;            root-&gt;children.push_back(std::move(componentNode));&#10;        }&#10;        &#10;        return root;&#10;    }&#10;}" />
              <option name="updatedContent" value="#include &quot;Component.hpp&quot;&#10;#include &quot;Block.hpp&quot;&#10;#include &quot;imgui.h&quot;&#10;#include &lt;algorithm&gt;&#10;&#10;namespace Diagram {&#10;    ComponentBase* ComponentBase::s_selected = nullptr;&#10;&#10;    void ComponentBase::RenderComponentTree(std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        if (!ImGui::Begin(&quot;Component Tree&quot;)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        auto hierarchy = BuildHierarchy(components);&#10;        if (hierarchy) {&#10;            RenderTreeNode(*hierarchy, &amp;components);&#10;        }&#10;&#10;        ImGui::End();&#10;    }&#10;&#10;    void ComponentBase::RenderComponentEditor() noexcept {&#10;        if (!ImGui::Begin(&quot;Component Editor&quot;, nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (!s_selected) {&#10;            ImGui::TextDisabled(&quot;No component selected&quot;);&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (auto* block = dynamic_cast&lt;Block*&gt;(s_selected)) {&#10;            block-&gt;RenderUI(0);&#10;        } else {&#10;            ImGui::TextDisabled(&quot;Unknown component type&quot;);&#10;        }&#10;&#10;        ImGui::End();&#10;    }&#10;&#10;    void ComponentBase::RenderTreeNode(const ComponentBase::TreeNode&amp; node, std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;* components) noexcept {&#10;        ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_DefaultOpen;&#10;        &#10;        if (node.children.empty()) {&#10;            flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;&#10;        }&#10;        &#10;        if (s_selected == node.component) {&#10;            flags |= ImGuiTreeNodeFlags_Selected;&#10;        }&#10;&#10;        bool nodeOpen = ImGui::TreeNodeEx(node.name.c_str(), flags);&#10;        &#10;        if (ImGui::IsItemClicked() &amp;&amp; node.component) {&#10;            Select(node.component);&#10;        }&#10;&#10;        // Drag &amp; drop only for components (not for root node)&#10;        if (node.component) {&#10;            if (ImGui::BeginDragDropSource()) {&#10;                ImGui::SetDragDropPayload(&quot;COMPONENT_DND&quot;, &amp;node.component, sizeof(void*));&#10;                ImGui::Text(&quot;Moving: %s&quot;, node.name.c_str());&#10;                ImGui::EndDragDropSource();&#10;            }&#10;        }&#10;&#10;        if (nodeOpen &amp;&amp; !node.children.empty()) {&#10;            for (auto&amp; child : node.children) {&#10;                RenderTreeNode(*child, components);&#10;                &#10;                // Drop target for reorder&#10;                if (child-&gt;component &amp;&amp; ImGui::BeginDragDropTarget()) {&#10;                    if (const auto* payload = ImGui::AcceptDragDropPayload(&quot;COMPONENT_DND&quot;)) {&#10;                        auto* draggedComp = *static_cast&lt;ComponentBase**&gt;(payload-&gt;Data);&#10;                        if (components &amp;&amp; draggedComp != child-&gt;component) {&#10;                            auto draggedIt = std::find_if(components-&gt;begin(), components-&gt;end(),&#10;                                [draggedComp](const auto&amp; c) { return c.get() == draggedComp; });&#10;                            auto targetIt = std::find_if(components-&gt;begin(), components-&gt;end(),&#10;                                [&amp;child](const auto&amp; c) { return c.get() == child-&gt;component; });&#10;                            &#10;                            if (draggedIt != components-&gt;end() &amp;&amp; targetIt != components-&gt;end()) {&#10;                                std::iter_swap(draggedIt, targetIt);&#10;                            }&#10;                        }&#10;                    }&#10;                    ImGui::EndDragDropTarget();&#10;                }&#10;            }&#10;            ImGui::TreePop();&#10;        }&#10;    }&#10;&#10;    std::unique_ptr&lt;ComponentBase::TreeNode&gt; ComponentBase::BuildHierarchy(const std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        auto root = std::make_unique&lt;TreeNode&gt;(&quot;Scene&quot;);&#10;        &#10;        for (const auto&amp; component : components) {&#10;            auto componentNode = std::make_unique&lt;TreeNode&gt;(&#10;                component-&gt;GetDisplayName(),&#10;                component.get()&#10;            );&#10;            root-&gt;children.push_back(std::move(componentNode));&#10;        }&#10;        &#10;        return root;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Main/DiagramData.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Main/DiagramData.cpp" />
              <option name="originalContent" value="#include &quot;DiagramData.hpp&quot;&#10;#include &lt;pugixml.hpp&gt;&#10;#include &lt;iostream&gt;&#10;#include &quot;../Utils/Path.hpp&quot;&#10;#include &quot;../Diagram/Block.hpp&quot;&#10;#include &quot;../Utils/Notification.hpp&quot;&#10;&#10;DiagramData::DiagramData() noexcept {&#10;    Load((Utils::GetWorkspacePath() / &quot;Default.xml&quot;).string());&#10;}&#10;&#10;void DiagramData::Load(const std::string&amp; filePath) {&#10;    pugi::xml_document doc;&#10;    pugi::xml_parse_result result = doc.load_file(filePath.c_str());&#10;    if (!result) {&#10;        std::cerr &lt;&lt; &quot;Error loading file: &quot; &lt;&lt; result.description() &lt;&lt; std::endl;&#10;        return;&#10;    }&#10;&#10;    m_components.clear();&#10;    auto diagram = doc.child(&quot;Diagram&quot;);&#10;    if (!diagram) return;&#10;&#10;    if (auto cameraNode = diagram.child(&quot;Camera&quot;)) {&#10;        m_camera.xml_deserialize(cameraNode);&#10;    }&#10;&#10;    if (auto gridNode = diagram.child(&quot;Grid&quot;)) {&#10;        m_grid.xml_deserialize(gridNode);&#10;    }&#10;&#10;    auto loadComponents = [&amp;](pugi::xml_node parent) {&#10;        for (pugi::xml_node componentNode : parent.children()) {&#10;            if (auto component = CreateComponent(componentNode.name())) {&#10;                component-&gt;xml_deserialize(componentNode);&#10;                m_components.push_back(std::move(component));&#10;            }&#10;        }&#10;    };&#10;&#10;    if (auto componentsNode = diagram.child(&quot;Components&quot;)) {&#10;        loadComponents(componentsNode);&#10;    }&#10;}&#10;&#10;void DiagramData::Save(const std::string&amp; filePath) const {&#10;    pugi::xml_document doc;&#10;    auto declarationNode = doc.append_child(pugi::node_declaration);&#10;    declarationNode.append_attribute(&quot;version&quot;) = &quot;1.0&quot;;&#10;    declarationNode.append_attribute(&quot;encoding&quot;) = &quot;UTF-8&quot;;&#10;&#10;    auto diagram = doc.append_child(&quot;Diagram&quot;);&#10;&#10;    auto cameraNode = diagram.append_child(&quot;Camera&quot;);&#10;    m_camera.xml_serialize(cameraNode);&#10;&#10;    auto gridNode = diagram.append_child(&quot;Grid&quot;);&#10;    m_grid.xml_serialize(gridNode);&#10;&#10;    auto componentsNode = diagram.append_child(&quot;Components&quot;);&#10;    for (const auto&amp; component : m_components) {&#10;        auto typeName = component-&gt;GetTypeName();&#10;        auto componentNode = componentsNode.append_child(typeName.c_str());&#10;        component-&gt;xml_serialize(componentNode);&#10;    }&#10;&#10;    if(doc.save_file(filePath.c_str())) {&#10;        Notify::Success(&quot;Diagram saved successfully!&quot;);&#10;    } else {&#10;        Notify::Error(&quot;Error saving diagram!&quot;);&#10;    }&#10;}&#10;&#10;std::unique_ptr&lt;Diagram::ComponentBase&gt; DiagramData::CreateComponent(const std::string&amp; type) const {&#10;    if (type == &quot;Block&quot;) return std::make_unique&lt;Diagram::Block&gt;();&#10;    return nullptr;&#10;}&#10;&#10;void DiagramData::AddBlock(bool useCursorPosition, SDL_Window* window) noexcept&#10;{&#10;    size_t blockCount = GetComponentsOfType&lt;Diagram::Block&gt;().size();&#10;&#10;    auto newBlock = std::make_unique&lt;Diagram::Block&gt;();&#10;&#10;    if (useCursorPosition &amp;&amp; window) {&#10;        ImVec2 mousePos = ImGui::GetMousePos();&#10;&#10;        int w, h;&#10;        SDL_GetWindowSize(window, &amp;w, &amp;h);&#10;        glm::vec2 screenCenter(w / 2.0f, h / 2.0f);&#10;&#10;        newBlock-&gt;data.position.x = (mousePos.x - screenCenter.x) / m_camera.data.zoom + m_camera.data.position.x;&#10;        newBlock-&gt;data.position.y = (mousePos.y - screenCenter.y) / m_camera.data.zoom + m_camera.data.position.y;&#10;    } else {&#10;        newBlock-&gt;data.position = {100.0f + static_cast&lt;float&gt;(blockCount + 1) * 150.0f, 100.0f};&#10;    }&#10;&#10;    newBlock-&gt;data.label = &quot;Block &quot; + std::to_string(blockCount + 1);&#10;    m_components.push_back(std::move(newBlock));&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;DiagramData.hpp&quot;&#10;#include &lt;pugixml.hpp&gt;&#10;#include &lt;iostream&gt;&#10;#include &quot;../Utils/Path.hpp&quot;&#10;#include &quot;../Diagram/Block.hpp&quot;&#10;#include &quot;../Utils/Notification.hpp&quot;&#10;&#10;DiagramData::DiagramData() noexcept {&#10;    Load((Utils::GetWorkspacePath() / &quot;Default.xml&quot;).string());&#10;}&#10;&#10;void DiagramData::Load(const std::string&amp; filePath) {&#10;    pugi::xml_document doc;&#10;    pugi::xml_parse_result result = doc.load_file(filePath.c_str());&#10;    if (!result) {&#10;        std::cerr &lt;&lt; &quot;Error loading file: &quot; &lt;&lt; result.description() &lt;&lt; std::endl;&#10;        return;&#10;    }&#10;&#10;    m_components.clear();&#10;    auto diagram = doc.child(&quot;Diagram&quot;);&#10;    if (!diagram) return;&#10;&#10;    if (auto cameraNode = diagram.child(&quot;Camera&quot;)) {&#10;        m_camera.xml_deserialize(cameraNode);&#10;    }&#10;&#10;    if (auto gridNode = diagram.child(&quot;Grid&quot;)) {&#10;        m_grid.xml_deserialize(gridNode);&#10;    }&#10;&#10;    auto loadComponents = [&amp;](pugi::xml_node parent) {&#10;        for (pugi::xml_node componentNode : parent.children()) {&#10;            if (auto component = CreateComponent(componentNode.name())) {&#10;                component-&gt;xml_deserialize(componentNode);&#10;                m_components.push_back(std::move(component));&#10;            }&#10;        }&#10;    };&#10;&#10;    if (auto componentsNode = diagram.child(&quot;Components&quot;)) {&#10;        loadComponents(componentsNode);&#10;    }&#10;}&#10;&#10;void DiagramData::Save(const std::string&amp; filePath) const {&#10;    pugi::xml_document doc;&#10;    auto declarationNode = doc.append_child(pugi::node_declaration);&#10;    declarationNode.append_attribute(&quot;version&quot;) = &quot;1.0&quot;;&#10;    declarationNode.append_attribute(&quot;encoding&quot;) = &quot;UTF-8&quot;;&#10;&#10;    auto diagram = doc.append_child(&quot;Diagram&quot;);&#10;&#10;    auto cameraNode = diagram.append_child(&quot;Camera&quot;);&#10;    m_camera.xml_serialize(cameraNode);&#10;&#10;    auto gridNode = diagram.append_child(&quot;Grid&quot;);&#10;    m_grid.xml_serialize(gridNode);&#10;&#10;    auto componentsNode = diagram.append_child(&quot;Components&quot;);&#10;    for (const auto&amp; component : m_components) {&#10;        auto typeName = component-&gt;GetTypeName();&#10;        auto componentNode = componentsNode.append_child(typeName.c_str());&#10;        component-&gt;xml_serialize(componentNode);&#10;    }&#10;&#10;    if(doc.save_file(filePath.c_str())) {&#10;        Notify::Success(&quot;Diagram saved successfully!&quot;);&#10;    } else {&#10;        Notify::Error(&quot;Error saving diagram!&quot;);&#10;    }&#10;}&#10;&#10;std::unique_ptr&lt;Diagram::ComponentBase&gt; DiagramData::CreateComponent(const std::string&amp; type) const {&#10;    if (type == &quot;Block&quot;) return std::make_unique&lt;Diagram::Block&gt;();&#10;    return nullptr;&#10;}&#10;&#10;void DiagramData::AddBlock(bool useCursorPosition, SDL_Window* window) noexcept&#10;{&#10;    size_t blockCount = GetComponentsOfType&lt;Diagram::Block&gt;().size();&#10;&#10;    auto newBlock = std::make_unique&lt;Diagram::Block&gt;();&#10;&#10;    if (useCursorPosition &amp;&amp; window) {&#10;        ImVec2 mousePos = ImGui::GetMousePos();&#10;&#10;        int w, h;&#10;        SDL_GetWindowSize(window, &amp;w, &amp;h);&#10;        glm::vec2 screenCenter(w / 2.0f, h / 2.0f);&#10;&#10;        newBlock-&gt;data.position.x = (mousePos.x - screenCenter.x) / m_camera.data.zoom + m_camera.data.position.x;&#10;        newBlock-&gt;data.position.y = (mousePos.y - screenCenter.y) / m_camera.data.zoom + m_camera.data.position.y;&#10;    } else {&#10;        newBlock-&gt;data.position = m_camera.data.position - newBlock-&gt;data.size / 2.0f;&#10;    }&#10;&#10;    newBlock-&gt;data.label = &quot;Block &quot; + std::to_string(blockCount + 1);&#10;    m_components.push_back(std::move(newBlock));&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>