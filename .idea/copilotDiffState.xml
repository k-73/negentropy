<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Core/Diagram/Component.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Diagram/Component.cpp" />
              <option name="originalContent" value="#include &quot;Component.hpp&quot;&#10;#include &quot;Block.hpp&quot;&#10;#include &quot;imgui.h&quot;&#10;#include &lt;algorithm&gt;&#10;#include &lt;set&gt;&#10;#include &quot;../Utils/IconsFontAwesome5.h&quot;&#10;#include &lt;imgui_internal.h&gt;&#10;&#10;namespace Diagram {&#10;    ComponentBase* ComponentBase::s_selected = nullptr;&#10;&#10;    void ComponentBase::RenderComponentTree(std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(8.0f, 8.0f));&#10;&#10;        if (!ImGui::Begin(&quot;Component Tree&quot;)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (ImGui::BeginTable(&quot;TreeTable&quot;, 2, ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_NoPadInnerX)) {&#10;            ImGui::TableSetupColumn(&quot;Name&quot;, ImGuiTableColumnFlags_WidthStretch);&#10;            ImGui::TableSetupColumn(&quot;Actions&quot;, ImGuiTableColumnFlags_WidthFixed, 28.0f);&#10;            &#10;            auto hierarchy = BuildHierarchy(components);&#10;            if (hierarchy) RenderTreeNode(*hierarchy, &amp;components);&#10;            &#10;            ImGui::EndTable();&#10;        }&#10;        ImGui::End();&#10;    }&#10;&#10;    void ComponentBase::RenderComponentEditor() noexcept {&#10;        if (!ImGui::Begin(&quot;Component Editor&quot;, nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (!s_selected) {&#10;            ImGui::TextDisabled(&quot;No component selected&quot;);&#10;        } else if (auto* block = dynamic_cast&lt;Block*&gt;(s_selected)) {&#10;            block-&gt;RenderUI(0);&#10;        } else {&#10;            ImGui::TextDisabled(&quot;Unknown component type&quot;);&#10;        }&#10;&#10;        ImGui::End();&#10;&#10;        ImGui::PopStyleVar();&#10;    }&#10;&#10;    void ComponentBase::RenderTreeNode(const TreeNode&amp; node, std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;* components) noexcept {&#10;        static constexpr float TREE_INDENT = 4.0f;&#10;        static int depth = 0;&#10;        static std::set&lt;std::string&gt; expanded;&#10;        static std::string hoveredRowId;&#10;        &#10;        // Reset hover state when starting new tree render (depth 0)&#10;        if (depth == 0) {&#10;            hoveredRowId.clear();&#10;        }&#10;        &#10;        const char* icon = node.component ? ICON_FA_CUBE : ICON_FA_SITEMAP;&#10;        std::string nodeKey = node.name + std::to_string(reinterpret_cast&lt;uintptr_t&gt;(node.component));&#10;        bool hasChildren = !node.children.empty();&#10;        bool isExpanded = expanded.contains(nodeKey) || (node.name == &quot;Scene&quot; &amp;&amp; expanded.empty());&#10;        ImGui::PushID(nodeKey.c_str());&#10;        ImGui::TableNextRow();&#10;        ImGui::TableNextColumn();&#10;        &#10;        ImGui::Indent(static_cast&lt;float&gt;(depth) * TREE_INDENT);&#10;        &#10;        if (hasChildren) {&#10;            if (ImGui::ArrowButton(&quot;##expand&quot;, isExpanded ? ImGuiDir_Down : ImGuiDir_Right)) {&#10;                if (isExpanded) expanded.erase(nodeKey);&#10;                else expanded.insert(nodeKey);&#10;            }&#10;            ImGui::SameLine(0, 2);&#10;        } else if (node.component) {&#10;            ImGui::Dummy(ImVec2(ImGui::GetFrameHeight(), 0));&#10;            ImGui::SameLine(0, 2);&#10;        }&#10;        &#10;        std::string displayText = &quot; &quot; + std::string(icon) + &quot;  &quot; + node.name;&#10;        bool selectableClicked = ImGui::Selectable(displayText.c_str(), s_selected == node.component);&#10;        bool nameHovered = ImGui::IsItemHovered();&#10;        &#10;        if (selectableClicked &amp;&amp; node.component) {&#10;            Select(node.component);&#10;        }&#10;        &#10;        if (node.component &amp;&amp; ImGui::BeginDragDropSource()) {&#10;            ImGui::SetDragDropPayload(&quot;COMPONENT_DND&quot;, &amp;node.component, sizeof(void*));&#10;            ImGui::Text(&quot;Moving: %s&quot;, node.name.c_str());&#10;            ImGui::EndDragDropSource();&#10;        }&#10;        &#10;        if (ImGui::BeginDragDropTarget()) {&#10;            if (const auto* payload = ImGui::AcceptDragDropPayload(&quot;COMPONENT_DND&quot;)) {&#10;                auto* dragged = static_cast&lt;ComponentBase**&gt;(payload-&gt;Data)[0];&#10;                if (dragged &amp;&amp; dragged != node.component) {&#10;                    auto draggedIt = std::ranges::find_if(*components, [dragged](const auto&amp; c) { return c.get() == dragged; });&#10;                    if (draggedIt != components-&gt;end()) {&#10;                        auto targetIt = node.component ? std::ranges::find_if(*components, [&amp;](const auto&amp; c) { return c.get() == node.component; }) : components-&gt;end();&#10;                        &#10;                        ptrdiff_t draggedIdx = std::distance(components-&gt;begin(), draggedIt);&#10;                        ptrdiff_t targetIdx = targetIt != components-&gt;end() ? std::distance(components-&gt;begin(), targetIt) : static_cast&lt;ptrdiff_t&gt;(components-&gt;size());&#10;                        &#10;                        auto draggedPtr = std::move(*draggedIt);&#10;                        components-&gt;erase(draggedIt);&#10;                        &#10;                        if (!node.component) {&#10;                            components-&gt;insert(components-&gt;begin(), std::move(draggedPtr));&#10;                        } else if (draggedIdx &lt; targetIdx) {&#10;                            components-&gt;insert(components-&gt;begin() + targetIdx, std::move(draggedPtr));&#10;                        } else {&#10;                            components-&gt;insert(components-&gt;begin() + targetIdx, std::move(draggedPtr));&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            ImGui::EndDragDropTarget();&#10;        }&#10;        &#10;        ImGui::Unindent(static_cast&lt;float&gt;(depth) * TREE_INDENT);&#10;        ImGui::TableNextColumn();&#10;        &#10;        if (node.component) {&#10;            ImVec2 columnStart = ImGui::GetCursorScreenPos();&#10;            ImVec2 columnEnd = ImVec2(columnStart.x + ImGui::GetContentRegionAvail().x, columnStart.y + ImGui::GetFrameHeight());&#10;            bool actionsColumnHovered = ImGui::IsMouseHoveringRect(columnStart, columnEnd);&#10;            &#10;            if (nameHovered || actionsColumnHovered) {&#10;                hoveredRowId = nodeKey;&#10;            }&#10;            &#10;            if (hoveredRowId == nodeKey) {&#10;                float columnWidth = ImGui::GetColumnWidth();&#10;                ImVec2 padding = ImGui::GetStyle().FramePadding;&#10;                float buttonWidth = ImGui::CalcTextSize(ICON_FA_TRASH).x + padding.x * 2.0f;&#10;                float buttonPosX = ImGui::GetCursorPosX() + (columnWidth - buttonWidth) * 0.5f;&#10;&#10;                ImGui::SetCursorPosX(buttonPosX);&#10;&#10;                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4{});&#10;                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.8f, 0.2f, 0.2f, 0.3f));&#10;                ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.9f, 0.3f, 0.3f, 0.5f));&#10;&#10;                if (ImGui::SmallButton(ICON_FA_TRASH &quot;##trash&quot;)) {&#10;                    if (auto it = std::ranges::find_if(*components, [&amp;](const auto&amp; c) { return c.get() == node.component; }); it != components-&gt;end()) {&#10;                        if (s_selected == node.component) ClearSelection();&#10;                        components-&gt;erase(it);&#10;                        ImGui::PopStyleColor(3);&#10;                        ImGui::PopID();&#10;                        return;&#10;                    }&#10;                }&#10;                ImGui::PopStyleColor(3);&#10;            }&#10;        } else if (node.name == &quot;Scene&quot;) {&#10;            float availWidth = ImGui::GetContentRegionAvail().x;&#10;            float iconWidth = ImGui::CalcTextSize(ICON_FA_FOLDER).x;&#10;            ImGui::SetCursorPosX(ImGui::GetCursorPosX() + (availWidth - iconWidth) * 0.5f);&#10;            &#10;            ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.7f, 0.7f, 0.7f, 1.0f));&#10;            ImGui::Text(ICON_FA_FOLDER);&#10;            ImGui::PopStyleColor();&#10;        }&#10;        &#10;        if (isExpanded &amp;&amp; hasChildren) {&#10;            ++depth;&#10;            for (const auto&amp; child : node.children) RenderTreeNode(*child, components);&#10;            --depth;&#10;        }&#10;        &#10;        ImGui::PopID();&#10;    }&#10;&#10;    std::unique_ptr&lt;ComponentBase::TreeNode&gt; ComponentBase::BuildHierarchy(const std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        auto root = std::make_unique&lt;TreeNode&gt;(&quot;Scene&quot;);&#10;        for (const auto&amp; component : components) {&#10;            root-&gt;children.push_back(std::make_unique&lt;TreeNode&gt;(component-&gt;GetDisplayName(), component.get()));&#10;        }&#10;        return root;&#10;    }&#10;}" />
              <option name="updatedContent" value="#include &quot;Component.hpp&quot;&#10;#include &quot;Block.hpp&quot;&#10;#include &quot;imgui.h&quot;&#10;#include &lt;algorithm&gt;&#10;#include &lt;set&gt;&#10;#include &quot;../Utils/IconsFontAwesome5.h&quot;&#10;#include &lt;imgui_internal.h&gt;&#10;&#10;namespace Diagram {&#10;    ComponentBase* ComponentBase::s_selected = nullptr;&#10;&#10;    void ComponentBase::RenderComponentTree(std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(8.0f, 8.0f));&#10;&#10;        if (!ImGui::Begin(&quot;Component Tree&quot;)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (ImGui::BeginTable(&quot;TreeTable&quot;, 2, ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_NoPadInnerX)) {&#10;            ImGui::TableSetupColumn(&quot;Name&quot;, ImGuiTableColumnFlags_WidthStretch);&#10;            ImGui::TableSetupColumn(&quot;Actions&quot;, ImGuiTableColumnFlags_WidthFixed, 28.0f);&#10;            &#10;            auto hierarchy = BuildHierarchy(components);&#10;            if (hierarchy) RenderTreeNode(*hierarchy, &amp;components);&#10;            &#10;            ImGui::EndTable();&#10;        }&#10;        ImGui::End();&#10;    }&#10;&#10;    void ComponentBase::RenderComponentEditor() noexcept {&#10;        if (!ImGui::Begin(&quot;Component Editor&quot;, nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (!s_selected) {&#10;            ImGui::TextDisabled(&quot;No component selected&quot;);&#10;        } else if (auto* block = dynamic_cast&lt;Block*&gt;(s_selected)) {&#10;            block-&gt;RenderUI(0);&#10;        } else {&#10;            ImGui::TextDisabled(&quot;Unknown component type&quot;);&#10;        }&#10;&#10;        ImGui::End();&#10;&#10;        ImGui::PopStyleVar();&#10;    }&#10;&#10;    void ComponentBase::RenderTreeNode(const TreeNode&amp; node, std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;* components) noexcept {&#10;        static constexpr float TREE_INDENT = 4.0f;&#10;        static int depth = 0;&#10;        static std::set&lt;std::string&gt; expanded;&#10;        static std::string hoveredRowId;&#10;        &#10;        // Reset hover state when starting new tree render (depth 0)&#10;        if (depth == 0) {&#10;            hoveredRowId.clear();&#10;        }&#10;        &#10;        const char* icon = node.component ? ICON_FA_CUBE : ICON_FA_SITEMAP;&#10;        std::string nodeKey = node.name + std::to_string(reinterpret_cast&lt;uintptr_t&gt;(node.component));&#10;        bool hasChildren = !node.children.empty();&#10;        bool isExpanded = expanded.contains(nodeKey) || (node.name == &quot;Scene&quot; &amp;&amp; expanded.empty());&#10;        ImGui::PushID(nodeKey.c_str());&#10;        ImGui::TableNextRow();&#10;        ImGui::TableNextColumn();&#10;        &#10;        ImGui::Indent(static_cast&lt;float&gt;(depth) * TREE_INDENT);&#10;        &#10;        if (hasChildren) {&#10;            if (ImGui::ArrowButton(&quot;##expand&quot;, isExpanded ? ImGuiDir_Down : ImGuiDir_Right)) {&#10;                if (isExpanded) expanded.erase(nodeKey);&#10;                else expanded.insert(nodeKey);&#10;            }&#10;            ImGui::SameLine(0, 2);&#10;        } else if (node.component) {&#10;            ImGui::Dummy(ImVec2(ImGui::GetFrameHeight(), 0));&#10;            ImGui::SameLine(0, 2);&#10;        }&#10;        &#10;        std::string displayText = &quot; &quot; + std::string(icon) + &quot;  &quot; + node.name;&#10;        bool selectableClicked = ImGui::Selectable(displayText.c_str(), s_selected == node.component);&#10;        bool nameHovered = ImGui::IsItemHovered();&#10;        &#10;        if (selectableClicked &amp;&amp; node.component) {&#10;            Select(node.component);&#10;        }&#10;        &#10;        if (node.component &amp;&amp; ImGui::BeginDragDropSource()) {&#10;            ImGui::SetDragDropPayload(&quot;COMPONENT_DND&quot;, &amp;node.component, sizeof(void*));&#10;            ImGui::Text(&quot;Moving: %s&quot;, node.name.c_str());&#10;            ImGui::EndDragDropSource();&#10;        }&#10;        &#10;        if (ImGui::BeginDragDropTarget()) {&#10;            if (const auto* payload = ImGui::AcceptDragDropPayload(&quot;COMPONENT_DND&quot;)) {&#10;                auto* dragged = static_cast&lt;ComponentBase**&gt;(payload-&gt;Data)[0];&#10;                if (dragged &amp;&amp; dragged != node.component) {&#10;                    auto draggedIt = std::ranges::find_if(*components, [dragged](const auto&amp; c) { return c.get() == dragged; });&#10;                    if (draggedIt != components-&gt;end()) {&#10;                        auto targetIt = node.component ? std::ranges::find_if(*components, [&amp;](const auto&amp; c) { return c.get() == node.component; }) : components-&gt;end();&#10;                        &#10;                        ptrdiff_t draggedIdx = std::distance(components-&gt;begin(), draggedIt);&#10;                        ptrdiff_t targetIdx = targetIt != components-&gt;end() ? std::distance(components-&gt;begin(), targetIt) : static_cast&lt;ptrdiff_t&gt;(components-&gt;size());&#10;                        &#10;                        auto draggedPtr = std::move(*draggedIt);&#10;                        components-&gt;erase(draggedIt);&#10;                        &#10;                        if (!node.component) {&#10;                            components-&gt;insert(components-&gt;begin(), std::move(draggedPtr));&#10;                        } else if (draggedIdx &lt; targetIdx) {&#10;                            components-&gt;insert(components-&gt;begin() + targetIdx, std::move(draggedPtr));&#10;                        } else {&#10;                            components-&gt;insert(components-&gt;begin() + targetIdx, std::move(draggedPtr));&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            ImGui::EndDragDropTarget();&#10;        }&#10;        &#10;        ImGui::Unindent(static_cast&lt;float&gt;(depth) * TREE_INDENT);&#10;        ImGui::TableNextColumn();&#10;        &#10;        if (node.component) {&#10;            ImVec2 columnStart = ImGui::GetCursorScreenPos();&#10;            ImVec2 columnEnd = ImVec2(columnStart.x + ImGui::GetContentRegionAvail().x, columnStart.y + ImGui::GetFrameHeight());&#10;            bool actionsColumnHovered = ImGui::IsMouseHoveringRect(columnStart, columnEnd);&#10;            &#10;            if (nameHovered || actionsColumnHovered) {&#10;                hoveredRowId = nodeKey;&#10;            }&#10;            &#10;            if (hoveredRowId == nodeKey) {&#10;                float columnWidth = ImGui::GetColumnWidth();&#10;                ImVec2 padding = ImGui::GetStyle().FramePadding;&#10;                float buttonWidth = ImGui::CalcTextSize(ICON_FA_TRASH).x + padding.x * 2.0f;&#10;                float buttonPosX = ImGui::GetCursorPosX() + (columnWidth - buttonWidth) * 0.5f;&#10;&#10;                ImGui::SetCursorPosX(buttonPosX);&#10;&#10;                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4{});&#10;                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.8f, 0.2f, 0.2f, 0.3f));&#10;                ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.9f, 0.3f, 0.3f, 0.5f));&#10;                ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(4.0f, ImGui::GetStyle().FramePadding.y)); // Adjust horizontal padding&#10;&#10;                if (ImGui::Button(ICON_FA_TRASH &quot;##trash&quot;)) {&#10;                    if (auto it = std::ranges::find_if(*components, [&amp;](const auto&amp; c) { return c.get() == node.component; }); it != components-&gt;end()) {&#10;                        if (s_selected == node.component) ClearSelection();&#10;                        components-&gt;erase(it);&#10;                        ImGui::PopStyleVar();&#10;                        ImGui::PopStyleColor(3);&#10;                        ImGui::PopID();&#10;                        return;&#10;                    }&#10;                }&#10;                ImGui::PopStyleVar();&#10;                ImGui::PopStyleColor(3);&#10;            }&#10;        } else if (node.name == &quot;Scene&quot;) {&#10;            float availWidth = ImGui::GetContentRegionAvail().x;&#10;            float iconWidth = ImGui::CalcTextSize(ICON_FA_FOLDER).x;&#10;            ImGui::SetCursorPosX(ImGui::GetCursorPosX() + (availWidth - iconWidth) * 0.5f);&#10;            &#10;            ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.7f, 0.7f, 0.7f, 1.0f));&#10;            ImGui::Text(ICON_FA_FOLDER);&#10;            ImGui::PopStyleColor();&#10;        }&#10;        &#10;        if (isExpanded &amp;&amp; hasChildren) {&#10;            ++depth;&#10;            for (const auto&amp; child : node.children) RenderTreeNode(*child, components);&#10;            --depth;&#10;        }&#10;        &#10;        ImGui::PopID();&#10;    }&#10;&#10;    std::unique_ptr&lt;ComponentBase::TreeNode&gt; ComponentBase::BuildHierarchy(const std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        auto root = std::make_unique&lt;TreeNode&gt;(&quot;Scene&quot;);&#10;        for (const auto&amp; component : components) {&#10;            root-&gt;children.push_back(std::make_unique&lt;TreeNode&gt;(component-&gt;GetDisplayName(), component.get()));&#10;        }&#10;        return root;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/css/app.scss">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/css/app.scss" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>