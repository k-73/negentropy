<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Core/Diagram/Component.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Diagram/Component.cpp" />
              <option name="originalContent" value="#include &quot;Component.hpp&quot;&#10;#include &quot;Block.hpp&quot;&#10;#include &quot;imgui.h&quot;&#10;#include &lt;algorithm&gt;&#10;#include &lt;set&gt;&#10;#include &quot;../Utils/IconsFontAwesome5.h&quot;&#10;#include &lt;imgui_internal.h&gt;&#10;&#10;namespace Diagram {&#10;    ComponentBase* ComponentBase::s_selected = nullptr;&#10;&#10;    void ComponentBase::RenderComponentTree(std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(8.0f, 8.0f));&#10;&#10;        if (!ImGui::Begin(&quot;Component Tree&quot;)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (ImGui::BeginTable(&quot;TreeTable&quot;, 2, ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_NoPadInnerX)) {&#10;            ImGui::TableSetupColumn(&quot;Name&quot;, ImGuiTableColumnFlags_WidthStretch);&#10;            ImGui::TableSetupColumn(&quot;Actions&quot;, ImGuiTableColumnFlags_WidthFixed, 28.0f);&#10;            &#10;            auto hierarchy = BuildHierarchy(components);&#10;            if (hierarchy) {&#10;                std::string hoveredRowId;&#10;                RenderTreeNode(*hierarchy, &amp;components, 0, hoveredRowId);&#10;            }&#10;&#10;            ImGui::EndTable();&#10;        }&#10;        ImGui::End();&#10;    }&#10;&#10;    void ComponentBase::RenderComponentEditor() noexcept {&#10;        if (!ImGui::Begin(&quot;Component Editor&quot;, nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (!s_selected) {&#10;            ImGui::TextDisabled(&quot;No component selected&quot;);&#10;        } else if (auto* block = dynamic_cast&lt;Block*&gt;(s_selected)) {&#10;            block-&gt;RenderUI(0);&#10;        } else {&#10;            ImGui::TextDisabled(&quot;Unknown component type&quot;);&#10;        }&#10;&#10;        ImGui::End();&#10;&#10;        ImGui::PopStyleVar();&#10;    }&#10;&#10;    void ComponentBase::RenderTreeNode(const TreeNode&amp; node, std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;* components, int depth, std::string&amp; hoveredRowId) noexcept {&#10;        static constexpr float TREE_INDENT = 4.0f;&#10;        static std::set&lt;std::string&gt; expanded;&#10;&#10;        const char* icon = node.component ? ICON_FA_CUBE : ICON_FA_SITEMAP;&#10;        std::string nodeKey = node.name + std::to_string(reinterpret_cast&lt;uintptr_t&gt;(node.component));&#10;        bool hasChildren = !node.children.empty();&#10;        bool isExpanded = expanded.contains(nodeKey) || (node.name == &quot;Scene&quot; &amp;&amp; expanded.empty());&#10;        ImGui::PushID(nodeKey.c_str());&#10;        ImGui::TableNextRow();&#10;        ImGui::TableNextColumn();&#10;        &#10;        ImGui::Indent(static_cast&lt;float&gt;(depth) * TREE_INDENT);&#10;        &#10;        if (hasChildren) {&#10;            if (ImGui::ArrowButton(&quot;##expand&quot;, isExpanded ? ImGuiDir_Down : ImGuiDir_Right)) {&#10;                if (isExpanded) expanded.erase(nodeKey);&#10;                else expanded.insert(nodeKey);&#10;            }&#10;            ImGui::SameLine(0, 2);&#10;        } else if (node.component) {&#10;            ImGui::Dummy(ImVec2(ImGui::GetFrameHeight(), 0));&#10;            ImGui::SameLine(0, 2);&#10;        }&#10;        &#10;        std::string displayText = &quot; &quot; + std::string(icon) + &quot;  &quot; + node.name;&#10;        bool selectableClicked = ImGui::Selectable(displayText.c_str(), s_selected == node.component);&#10;        bool nameHovered = ImGui::IsItemHovered();&#10;        &#10;        if (selectableClicked &amp;&amp; node.component) {&#10;            Select(node.component);&#10;        }&#10;        &#10;        if (node.component &amp;&amp; ImGui::BeginDragDropSource()) {&#10;            ImGui::SetDragDropPayload(&quot;COMPONENT_DND&quot;, &amp;node.component, sizeof(void*));&#10;            ImGui::Text(&quot;Moving: %s&quot;, node.name.c_str());&#10;            ImGui::EndDragDropSource();&#10;        }&#10;        &#10;        if (ImGui::BeginDragDropTarget()) {&#10;            if (const auto* payload = ImGui::AcceptDragDropPayload(&quot;COMPONENT_DND&quot;)) {&#10;                auto* dragged = static_cast&lt;ComponentBase**&gt;(payload-&gt;Data)[0];&#10;                if (dragged &amp;&amp; dragged != node.component) {&#10;                    auto draggedIt = std::ranges::find_if(*components, [dragged](const auto&amp; c) { return c.get() == dragged; });&#10;                    if (draggedIt != components-&gt;end()) {&#10;                        auto targetIt = node.component ? std::ranges::find_if(*components, [&amp;](const auto&amp; c) { return c.get() == node.component; }) : components-&gt;end();&#10;                        &#10;                        ptrdiff_t draggedIdx = std::distance(components-&gt;begin(), draggedIt);&#10;                        ptrdiff_t targetIdx = targetIt != components-&gt;end() ? std::distance(components-&gt;begin(), targetIt) : static_cast&lt;ptrdiff_t&gt;(components-&gt;size());&#10;                        &#10;                        auto draggedPtr = std::move(*draggedIt);&#10;                        components-&gt;erase(draggedIt);&#10;                        &#10;                        if (!node.component) {&#10;                            components-&gt;insert(components-&gt;begin(), std::move(draggedPtr));&#10;                        } else if (draggedIdx &lt; targetIdx) {&#10;                            components-&gt;insert(components-&gt;begin() + targetIdx, std::move(draggedPtr));&#10;                        } else {&#10;                            components-&gt;insert(components-&gt;begin() + targetIdx, std::move(draggedPtr));&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            ImGui::EndDragDropTarget();&#10;        }&#10;        &#10;        ImGui::Unindent(static_cast&lt;float&gt;(depth) * TREE_INDENT);&#10;        ImGui::TableNextColumn();&#10;        &#10;        if (node.component) {&#10;            ImVec2 columnStart = ImGui::GetCursorScreenPos();&#10;            ImVec2 columnEnd = ImVec2(columnStart.x + ImGui::GetContentRegionAvail().x, columnStart.y + ImGui::GetFrameHeight());&#10;            bool actionsColumnHovered = ImGui::IsMouseHoveringRect(columnStart, columnEnd);&#10;            &#10;            if (nameHovered || actionsColumnHovered) {&#10;                hoveredRowId = nodeKey;&#10;            }&#10;            &#10;            if (hoveredRowId == nodeKey) {&#10;                float columnWidth = ImGui::GetColumnWidth();&#10;                float buttonWidth = ImGui::CalcTextSize(ICON_FA_TRASH).x + ImGui::GetStyle().FramePadding.x * 2.0f;&#10;                ImGui::SetCursorPosX(ImGui::GetCursorPosX() + (columnWidth - buttonWidth) * 0.5f);&#10;&#10;                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4{0, 0, 0, 0});&#10;                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4{0, 0, 0, 0});&#10;                ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4{0, 0, 0, 0});&#10;                ImGui::PushStyleColor(ImGuiCol_Text, ImGui::GetStyle().Colors[ImGuiCol_TextDisabled]);&#10;&#10;                if (ImGui::IsItemHovered()) {&#10;                    ImGui::PopStyleColor(); // Pop the disabled text color&#10;                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.9f, 0.2f, 0.2f, 1.0f));&#10;                }&#10;&#10;                bool deleted = false;&#10;                if (ImGui::SmallButton(ICON_FA_TRASH &quot;##trash&quot;)) {&#10;                    if (auto it = std::ranges::find_if(*components, [&amp;](const auto&amp; c) { return c.get() == node.component; }); it != components-&gt;end()) {&#10;                        if (s_selected == node.component) ClearSelection();&#10;                        components-&gt;erase(it);&#10;                        deleted = true;&#10;                    }&#10;                }&#10;                ImGui::PopStyleColor(4);&#10;&#10;                if (deleted) {&#10;                    ImGui::PopID();&#10;                    return;&#10;                }&#10;            }&#10;        } else if (node.name == &quot;Scene&quot;) {&#10;            float availWidth = ImGui::GetContentRegionAvail().x;&#10;            float iconWidth = ImGui::CalcTextSize(ICON_FA_FOLDER).x;&#10;            ImGui::SetCursorPosX(ImGui::GetCursorPosX() + (availWidth - iconWidth) * 0.5f);&#10;            &#10;            ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.7f, 0.7f, 0.7f, 1.0f));&#10;            ImGui::Text(ICON_FA_FOLDER);&#10;            ImGui::PopStyleColor();&#10;        }&#10;        &#10;        if (isExpanded &amp;&amp; hasChildren) {&#10;            for (const auto&amp; child : node.children) RenderTreeNode(*child, components, depth + 1, hoveredRowId);&#10;        }&#10;        &#10;        ImGui::PopID();&#10;    }&#10;&#10;    std::unique_ptr&lt;ComponentBase::TreeNode&gt; ComponentBase::BuildHierarchy(const std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        auto root = std::make_unique&lt;TreeNode&gt;(&quot;Scene&quot;);&#10;        for (const auto&amp; component : components) {&#10;            root-&gt;children.push_back(std::make_unique&lt;TreeNode&gt;(component-&gt;GetDisplayName(), component.get()));&#10;        }&#10;        return root;&#10;    }&#10;}" />
              <option name="updatedContent" value="#include &quot;Component.hpp&quot;&#10;#include &quot;Block.hpp&quot;&#10;#include &quot;imgui.h&quot;&#10;#include &lt;algorithm&gt;&#10;#include &lt;set&gt;&#10;#include &quot;../Utils/IconsFontAwesome5.h&quot;&#10;#include &lt;imgui_internal.h&gt;&#10;&#10;namespace Diagram {&#10;    ComponentBase* ComponentBase::s_selected = nullptr;&#10;&#10;    void ComponentBase::RenderComponentTree(std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(8.0f, 8.0f));&#10;&#10;        if (!ImGui::Begin(&quot;Component Tree&quot;)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (ImGui::BeginTable(&quot;TreeTable&quot;, 2, ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_NoPadInnerX)) {&#10;            ImGui::TableSetupColumn(&quot;Name&quot;, ImGuiTableColumnFlags_WidthStretch);&#10;            ImGui::TableSetupColumn(&quot;Actions&quot;, ImGuiTableColumnFlags_WidthFixed, 28.0f);&#10;            &#10;            auto hierarchy = BuildHierarchy(components);&#10;            if (hierarchy) {&#10;                std::string hoveredRowId;&#10;                RenderTreeNode(*hierarchy, &amp;components, 0, hoveredRowId);&#10;            }&#10;&#10;            ImGui::EndTable();&#10;        }&#10;        ImGui::End();&#10;    }&#10;&#10;    void ComponentBase::RenderComponentEditor() noexcept {&#10;        if (!ImGui::Begin(&quot;Component Editor&quot;, nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (!s_selected) {&#10;            ImGui::TextDisabled(&quot;No component selected&quot;);&#10;        } else if (auto* block = dynamic_cast&lt;Block*&gt;(s_selected)) {&#10;            block-&gt;RenderUI(0);&#10;        } else {&#10;            ImGui::TextDisabled(&quot;Unknown component type&quot;);&#10;        }&#10;&#10;        ImGui::End();&#10;&#10;        ImGui::PopStyleVar();&#10;    }&#10;&#10;    void ComponentBase::RenderTreeNode(const TreeNode&amp; node, std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;* components, int depth, std::string&amp; hoveredRowId) noexcept {&#10;        static constexpr float TREE_INDENT = 4.0f;&#10;        static std::set&lt;std::string&gt; expanded;&#10;&#10;        const char* icon = node.component ? ICON_FA_CUBE : ICON_FA_SITEMAP;&#10;        std::string nodeKey = node.name + std::to_string(reinterpret_cast&lt;uintptr_t&gt;(node.component));&#10;        bool hasChildren = !node.children.empty();&#10;        bool isExpanded = expanded.contains(nodeKey) || (node.name == &quot;Scene&quot; &amp;&amp; expanded.empty());&#10;        ImGui::PushID(nodeKey.c_str());&#10;        ImGui::TableNextRow();&#10;        ImGui::TableNextColumn();&#10;        &#10;        ImGui::Indent(static_cast&lt;float&gt;(depth) * TREE_INDENT);&#10;        &#10;        if (hasChildren) {&#10;            if (ImGui::ArrowButton(&quot;##expand&quot;, isExpanded ? ImGuiDir_Down : ImGuiDir_Right)) {&#10;                if (isExpanded) expanded.erase(nodeKey);&#10;                else expanded.insert(nodeKey);&#10;            }&#10;            ImGui::SameLine(0, 2);&#10;        } else if (node.component) {&#10;            ImGui::Dummy(ImVec2(ImGui::GetFrameHeight(), 0));&#10;            ImGui::SameLine(0, 2);&#10;        }&#10;        &#10;        std::string displayText = &quot; &quot; + std::string(icon) + &quot;  &quot; + node.name;&#10;        bool selectableClicked = ImGui::Selectable(displayText.c_str(), s_selected == node.component);&#10;        bool nameHovered = ImGui::IsItemHovered();&#10;        &#10;        if (selectableClicked &amp;&amp; node.component) {&#10;            Select(node.component);&#10;        }&#10;        &#10;        if (node.component &amp;&amp; ImGui::BeginDragDropSource()) {&#10;            ImGui::SetDragDropPayload(&quot;COMPONENT_DND&quot;, &amp;node.component, sizeof(void*));&#10;            ImGui::Text(&quot;Moving: %s&quot;, node.name.c_str());&#10;            ImGui::EndDragDropSource();&#10;        }&#10;        &#10;        if (ImGui::BeginDragDropTarget()) {&#10;            if (const auto* payload = ImGui::AcceptDragDropPayload(&quot;COMPONENT_DND&quot;)) {&#10;                auto* dragged = static_cast&lt;ComponentBase**&gt;(payload-&gt;Data)[0];&#10;                if (dragged &amp;&amp; dragged != node.component) {&#10;                    auto draggedIt = std::ranges::find_if(*components, [dragged](const auto&amp; c) { return c.get() == dragged; });&#10;                    if (draggedIt != components-&gt;end()) {&#10;                        auto targetIt = node.component ? std::ranges::find_if(*components, [&amp;](const auto&amp; c) { return c.get() == node.component; }) : components-&gt;end();&#10;                        &#10;                        ptrdiff_t draggedIdx = std::distance(components-&gt;begin(), draggedIt);&#10;                        ptrdiff_t targetIdx = targetIt != components-&gt;end() ? std::distance(components-&gt;begin(), targetIt) : static_cast&lt;ptrdiff_t&gt;(components-&gt;size());&#10;                        &#10;                        auto draggedPtr = std::move(*draggedIt);&#10;                        components-&gt;erase(draggedIt);&#10;                        &#10;                        if (!node.component) {&#10;                            components-&gt;insert(components-&gt;begin(), std::move(draggedPtr));&#10;                        } else if (draggedIdx &lt; targetIdx) {&#10;                            components-&gt;insert(components-&gt;begin() + targetIdx, std::move(draggedPtr));&#10;                        } else {&#10;                            components-&gt;insert(components-&gt;begin() + targetIdx, std::move(draggedPtr));&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            ImGui::EndDragDropTarget();&#10;        }&#10;        &#10;        ImGui::Unindent(static_cast&lt;float&gt;(depth) * TREE_INDENT);&#10;        ImGui::TableNextColumn();&#10;        &#10;        if (node.component) {&#10;            ImVec2 columnStart = ImGui::GetCursorScreenPos();&#10;            ImVec2 columnEnd = ImVec2(columnStart.x + ImGui::GetContentRegionAvail().x, columnStart.y + ImGui::GetFrameHeight());&#10;            bool actionsColumnHovered = ImGui::IsMouseHoveringRect(columnStart, columnEnd);&#10;            &#10;            if (nameHovered || actionsColumnHovered) {&#10;                hoveredRowId = nodeKey;&#10;            }&#10;            &#10;            if (hoveredRowId == nodeKey) {&#10;                float columnWidth = ImGui::GetColumnWidth();&#10;                float buttonWidth = ImGui::CalcTextSize(ICON_FA_TRASH).x + ImGui::GetStyle().FramePadding.x * 2.0f;&#10;                ImGui::SetCursorPosX(ImGui::GetCursorPosX() + (columnWidth - buttonWidth) * 0.5f);&#10;&#10;                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4{0, 0, 0, 0});&#10;                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4{0, 0, 0, 0});&#10;                ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4{0, 0, 0, 0});&#10;                &#10;                bool isButtonHovered = ImGui::IsWindowHovered() &amp;&amp; ImGui::IsMouseHoveringRect(&#10;                    ImGui::GetItemRectMin(), ImGui::GetItemRectMax(), false&#10;                );&#10;&#10;                ImVec4 textColor = isButtonHovered ? ImVec4(0.9f, 0.2f, 0.2f, 1.0f) : ImGui::GetStyle().Colors[ImGuiCol_TextDisabled];&#10;                ImGui::PushStyleColor(ImGuiCol_Text, textColor);&#10;&#10;                bool deleted = false;&#10;                if (ImGui::SmallButton(ICON_FA_TRASH &quot;##trash&quot;)) {&#10;                    if (auto it = std::ranges::find_if(*components, [&amp;](const auto&amp; c) { return c.get() == node.component; }); it != components-&gt;end()) {&#10;                        if (s_selected == node.component) ClearSelection();&#10;                        components-&gt;erase(it);&#10;                        deleted = true;&#10;                    }&#10;                }&#10;                ImGui::PopStyleColor(4);&#10;&#10;                if (deleted) {&#10;                    ImGui::PopID();&#10;                    return;&#10;                }&#10;            }&#10;        } else if (node.name == &quot;Scene&quot;) {&#10;            float availWidth = ImGui::GetContentRegionAvail().x;&#10;            float iconWidth = ImGui::CalcTextSize(ICON_FA_FOLDER).x;&#10;            ImGui::SetCursorPosX(ImGui::GetCursorPosX() + (availWidth - iconWidth) * 0.5f);&#10;            &#10;            ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.7f, 0.7f, 0.7f, 1.0f));&#10;            ImGui::Text(ICON_FA_FOLDER);&#10;            ImGui::PopStyleColor();&#10;        }&#10;        &#10;        if (isExpanded &amp;&amp; hasChildren) {&#10;            for (const auto&amp; child : node.children) RenderTreeNode(*child, components, depth + 1, hoveredRowId);&#10;        }&#10;        &#10;        ImGui::PopID();&#10;    }&#10;&#10;    std::unique_ptr&lt;ComponentBase::TreeNode&gt; ComponentBase::BuildHierarchy(const std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        auto root = std::make_unique&lt;TreeNode&gt;(&quot;Scene&quot;);&#10;        for (const auto&amp; component : components) {&#10;            root-&gt;children.push_back(std::make_unique&lt;TreeNode&gt;(component-&gt;GetDisplayName(), component.get()));&#10;        }&#10;        return root;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Diagram/Component.hpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Diagram/Component.hpp" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;glm/vec2.hpp&gt;&#10;#include &lt;SDL.h&gt;&#10;#include &lt;pugixml.hpp&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;typeinfo&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;cxxabi.h&gt;&#10;&#10;namespace Diagram {&#10;    struct Camera;&#10;    class Block;&#10;    &#10;    class ComponentBase {&#10;    public:&#10;        virtual ~ComponentBase() = default;&#10;        &#10;        virtual bool HandleEvent(const SDL_Event&amp; event, const Camera&amp; camera, glm::vec2 screenSize) noexcept = 0;&#10;        virtual void Render(SDL_Renderer* renderer, const Camera&amp; camera, glm::vec2 screenSize) const noexcept = 0;&#10;        virtual void xml_serialize(pugi::xml_node&amp; node) const = 0;&#10;        virtual void xml_deserialize(const pugi::xml_node&amp; node) = 0;&#10;        virtual std::string GetDisplayName() const noexcept = 0;&#10;        virtual std::string GetTypeName() const noexcept = 0;&#10;        &#10;        static ComponentBase* GetSelected() noexcept { return s_selected; }&#10;        static void Select(ComponentBase* component) noexcept { s_selected = component; }&#10;        static void ClearSelection() noexcept { s_selected = nullptr; }&#10;        &#10;        static void RenderComponentTree(std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept;&#10;        static void RenderComponentEditor() noexcept;&#10;        &#10;    private:&#10;        static ComponentBase* s_selected;&#10;        &#10;        struct TreeNode {&#10;            std::string name;&#10;            ComponentBase* component = nullptr;&#10;            std::vector&lt;std::unique_ptr&lt;TreeNode&gt;&gt; children;&#10;            &#10;            explicit TreeNode(std::string n, ComponentBase* c = nullptr)&#10;                : name(std::move(n)), component(c) {}&#10;        };&#10;        &#10;        static void RenderTreeNode(const TreeNode&amp; node, std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;* components) noexcept;&#10;        static std::unique_ptr&lt;TreeNode&gt; BuildHierarchy(const std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept;&#10;    };&#10;    &#10;    template&lt;typename T&gt;&#10;    std::string demangle() {&#10;        int status;&#10;        char* demangled = abi::__cxa_demangle(typeid(T).name(), 0, 0, &amp;status);&#10;        std::string result = demangled ? demangled : &quot;unknown&quot;;&#10;        free(demangled);&#10;        auto pos = result.find_last_of(&quot;::&quot;);&#10;        if (pos != std::string::npos) result = result.substr(pos + 1);&#10;        return result;&#10;    }&#10;    &#10;    template&lt;typename Derived&gt;&#10;    class Component : public ComponentBase {&#10;    public:&#10;        std::string GetTypeName() const noexcept override { return demangle&lt;Derived&gt;(); }&#10;        static std::string GetStaticTypeName() noexcept { return demangle&lt;Derived&gt;(); }&#10;    };&#10;    &#10;}" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;glm/vec2.hpp&gt;&#10;#include &lt;SDL.h&gt;&#10;#include &lt;pugixml.hpp&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;typeinfo&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;cxxabi.h&gt;&#10;&#10;namespace Diagram {&#10;    struct Camera;&#10;    class Block;&#10;    &#10;    class ComponentBase {&#10;    public:&#10;        struct TreeNode {&#10;            std::string name;&#10;            ComponentBase* component = nullptr;&#10;            std::vector&lt;std::unique_ptr&lt;TreeNode&gt;&gt; children;&#10;&#10;            explicit TreeNode(std::string n, ComponentBase* c = nullptr) : name(std::move(n)), component(c) {}&#10;        };&#10;&#10;        virtual ~ComponentBase() = default;&#10;        &#10;        virtual bool HandleEvent(const SDL_Event&amp; event, const Camera&amp; camera, glm::vec2 screenSize) noexcept = 0;&#10;        virtual void Render(SDL_Renderer* renderer, const Camera&amp; camera, glm::vec2 screenSize) const noexcept = 0;&#10;        virtual void xml_serialize(pugi::xml_node&amp; node) const = 0;&#10;        virtual void xml_deserialize(const pugi::xml_node&amp; node) = 0;&#10;        virtual std::string GetDisplayName() const noexcept = 0;&#10;        virtual std::string GetTypeName() const noexcept = 0;&#10;        &#10;        static ComponentBase* GetSelected() noexcept { return s_selected; }&#10;        static void Select(ComponentBase* component) noexcept { s_selected = component; }&#10;        static void ClearSelection() noexcept { s_selected = nullptr; }&#10;        &#10;        static void RenderComponentTree(std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept;&#10;        static void RenderComponentEditor() noexcept;&#10;        &#10;    private:&#10;        static ComponentBase* s_selected;&#10;        &#10;        static void RenderTreeNode(const TreeNode&amp; node, std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;* components, int depth, std::string&amp; hoveredRowId) noexcept;&#10;        static std::unique_ptr&lt;TreeNode&gt; BuildHierarchy(const std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept;&#10;    };&#10;    &#10;    template&lt;typename T&gt;&#10;    std::string demangle() {&#10;        int status;&#10;        char* demangled = abi::__cxa_demangle(typeid(T).name(), 0, 0, &amp;status);&#10;        std::string result = demangled ? demangled : &quot;unknown&quot;;&#10;        free(demangled);&#10;        auto pos = result.find_last_of(&quot;::&quot;);&#10;        if (pos != std::string::npos) result = result.substr(pos + 1);&#10;        return result;&#10;    }&#10;    &#10;    template&lt;typename Derived&gt;&#10;    class Component : public ComponentBase {&#10;    public:&#10;        std::string GetTypeName() const noexcept override { return demangle&lt;Derived&gt;(); }&#10;        static std::string GetStaticTypeName() noexcept { return demangle&lt;Derived&gt;(); }&#10;    };&#10;    &#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/css/app.scss">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/css/app.scss" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>