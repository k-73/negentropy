<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.16)&#10;project(negentropy LANGUAGES CXX)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;include(FetchContent)&#10;FetchContent_Declare(&#10;  nlohmann_json&#10;  GIT_REPOSITORY https://github.com/nlohmann/json.git&#10;  GIT_TAG v3.12.0&#10;)&#10;&#10;FetchContent_Declare(&#10;  spdlog&#10;  GIT_REPOSITORY https://github.com/gabime/spdlog.git&#10;  GIT_TAG v1.15.3&#10;)&#10;&#10;FetchContent_Declare(&#10;  imgui&#10;  GIT_REPOSITORY https://github.com/ocornut/imgui.git&#10;  GIT_TAG v1.92.1&#10;)&#10;&#10;FetchContent_Declare(&#10;  glm&#10;  GIT_REPOSITORY https://github.com/g-truc/glm.git&#10;  GIT_TAG 1.0.1&#10;)&#10;&#10;FetchContent_Declare(&#10;  entt&#10;  GIT_REPOSITORY https://github.com/skypjack/entt.git&#10;  GIT_TAG v3.15.0&#10;)&#10;&#10;FetchContent_Declare(&#10;  tracy&#10;  GIT_REPOSITORY https://github.com/wolfpld/tracy.git&#10;  GIT_TAG v0.12.2&#10;)&#10;&#10;FetchContent_Declare(&#10;  Catch2&#10;  GIT_REPOSITORY https://github.com/catchorg/Catch2.git&#10;  GIT_TAG v3.9.0&#10;)&#10;&#10;FetchContent_Declare(&#10;  magic_enum&#10;  GIT_REPOSITORY https://github.com/Neargye/magic_enum.git&#10;  GIT_TAG v0.9.7&#10;)&#10;&#10;FetchContent_MakeAvailable(nlohmann_json spdlog imgui glm entt tracy Catch2 magic_enum)&#10;&#10;find_package(SDL2 REQUIRED)&#10;&#10;file(GLOB_RECURSE SOURCES CONFIGURE_DEPENDS &quot;Core/*.cpp&quot; &quot;Core/*.hpp&quot;)&#10;&#10;# ImGui configuration&#10;FetchContent_GetProperties(imgui)&#10;if(NOT imgui_POPULATED)&#10;    FetchContent_Populate(imgui)&#10;endif()&#10;&#10;# ImGui sources&#10;set(IMGUI_SOURCES&#10;    ${imgui_SOURCE_DIR}/imgui.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_demo.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_draw.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_tables.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_widgets.cpp&#10;    ${imgui_SOURCE_DIR}/backends/imgui_impl_sdl2.cpp&#10;    ${imgui_SOURCE_DIR}/backends/imgui_impl_sdlrenderer2.cpp&#10;)&#10;&#10;add_executable(negentropy ${SOURCES} ${IMGUI_SOURCES})&#10;&#10;target_include_directories(negentropy PRIVATE &#10;    Core&#10;    ${imgui_SOURCE_DIR}&#10;    ${imgui_SOURCE_DIR}/backends&#10;)&#10;&#10;# Tracy configuration&#10;option(TRACY_ENABLE &quot;Enable Tracy profiler&quot; ON)&#10;if(TRACY_ENABLE)&#10;    target_compile_definitions(negentropy PRIVATE TRACY_ENABLE)&#10;endif()&#10;&#10;target_link_libraries(negentropy PRIVATE &#10;    SDL2::SDL2 &#10;    nlohmann_json::nlohmann_json &#10;    spdlog::spdlog&#10;    glm::glm&#10;    EnTT::EnTT&#10;    TracyClient&#10;    magic_enum::magic_enum&#10;)" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.16)&#10;project(negentropy LANGUAGES CXX)&#10;&#10;set(CMAKE_CXX_STANDARD 20)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;include(FetchContent)&#10;FetchContent_Declare(&#10;  nlohmann_json&#10;  GIT_REPOSITORY https://github.com/nlohmann/json.git&#10;  GIT_TAG v3.12.0&#10;)&#10;&#10;FetchContent_Declare(&#10;  spdlog&#10;  GIT_REPOSITORY https://github.com/gabime/spdlog.git&#10;  GIT_TAG v1.15.3&#10;)&#10;&#10;FetchContent_Declare(&#10;  imgui&#10;  GIT_REPOSITORY https://github.com/ocornut/imgui.git&#10;  GIT_TAG v1.92.1&#10;)&#10;&#10;FetchContent_Declare(&#10;  glm&#10;  GIT_REPOSITORY https://github.com/g-truc/glm.git&#10;  GIT_TAG 1.0.1&#10;)&#10;&#10;FetchContent_Declare(&#10;  entt&#10;  GIT_REPOSITORY https://github.com/skypjack/entt.git&#10;  GIT_TAG v3.15.0&#10;)&#10;&#10;FetchContent_Declare(&#10;  magic_enum&#10;  GIT_REPOSITORY https://github.com/Neargye/magic_enum.git&#10;  GIT_TAG v0.9.7&#10;)&#10;&#10;FetchContent_MakeAvailable(nlohmann_json spdlog imgui glm entt magic_enum)&#10;&#10;find_package(SDL2 REQUIRED)&#10;&#10;file(GLOB_RECURSE SOURCES CONFIGURE_DEPENDS &quot;Core/*.cpp&quot; &quot;Core/*.hpp&quot;)&#10;&#10;# ImGui configuration&#10;FetchContent_GetProperties(imgui)&#10;if(NOT imgui_POPULATED)&#10;    FetchContent_Populate(imgui)&#10;endif()&#10;&#10;# ImGui sources&#10;set(IMGUI_SOURCES&#10;    ${imgui_SOURCE_DIR}/imgui.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_demo.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_draw.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_tables.cpp&#10;    ${imgui_SOURCE_DIR}/imgui_widgets.cpp&#10;    ${imgui_SOURCE_DIR}/backends/imgui_impl_sdl2.cpp&#10;    ${imgui_SOURCE_DIR}/backends/imgui_impl_sdlrenderer2.cpp&#10;)&#10;&#10;add_executable(negentropy ${SOURCES} ${IMGUI_SOURCES})&#10;&#10;target_include_directories(negentropy PRIVATE &#10;    Core&#10;    ${imgui_SOURCE_DIR}&#10;    ${imgui_SOURCE_DIR}/backends&#10;)&#10;&#10;target_link_libraries(negentropy PRIVATE &#10;    SDL2::SDL2 &#10;    nlohmann_json::nlohmann_json &#10;    spdlog::spdlog&#10;    glm::glm&#10;    EnTT::EnTT&#10;    magic_enum::magic_enum&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Main/Application.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Main/Application.cpp" />
              <option name="originalContent" value="#include &quot;Application.hpp&quot;&#10;#include &quot;Renderer.hpp&quot;&#10;#include &quot;EventHandler.hpp&quot;&#10;#include &quot;DiagramData.hpp&quot;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;spdlog/spdlog.h&gt;&#10;#include &lt;imgui.h&gt;&#10;#include &lt;imgui_impl_sdl2.h&gt;&#10;#include &lt;imgui_impl_sdlrenderer2.h&gt;&#10;&#10;Application::Application() : m_renderer(std::make_unique&lt;Renderer&gt;()), m_eventHandler(std::make_unique&lt;EventHandler&gt;()), m_diagramData(std::make_unique&lt;DiagramData&gt;()) {&#10;    spdlog::info(&quot;Initializing application...&quot;);&#10;&#10;    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS) != 0)&#10;        throw std::runtime_error(&quot;SDL_Init error: &quot; + std::string(SDL_GetError()));&#10;    &#10;    int displayIndex = 0;&#10;    int mouseX, mouseY;&#10;    SDL_GetGlobalMouseState(&amp;mouseX, &amp;mouseY);&#10;    int numDisplays = SDL_GetNumVideoDisplays();&#10;    &#10;    for (int i = 0; i &lt; numDisplays; i++) {&#10;        SDL_Rect displayBounds;&#10;        if (SDL_GetDisplayBounds(i, &amp;displayBounds) == 0 &amp;&amp;&#10;            mouseX &gt;= displayBounds.x &amp;&amp; mouseX &lt; displayBounds.x + displayBounds.w &amp;&amp;&#10;            mouseY &gt;= displayBounds.y &amp;&amp; mouseY &lt; displayBounds.y + displayBounds.h) {&#10;            displayIndex = i;&#10;            break;&#10;        }&#10;    }&#10;&#10;    // Create window without OpenGL&#10;    m_window = SDL_CreateWindow(&quot;Negentropy - Diagram Editor&quot;,&#10;                                SDL_WINDOWPOS_CENTERED_DISPLAY(displayIndex), &#10;                                SDL_WINDOWPOS_CENTERED_DISPLAY(displayIndex), 1280, 720,&#10;                                SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI | SDL_WINDOW_HIDDEN);&#10;    if (!m_window) {&#10;        SDL_Quit();&#10;        throw std::runtime_error(&quot;SDL_CreateWindow error: &quot; + std::string(SDL_GetError()));&#10;    }&#10;&#10;    // Create SDL2 renderer with VSync&#10;    m_sdlRenderer = SDL_CreateRenderer(m_window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);&#10;    if (!m_sdlRenderer) {&#10;        spdlog::warn(&quot;Failed to create accelerated renderer with VSync, trying without...&quot;);&#10;        m_sdlRenderer = SDL_CreateRenderer(m_window, -1, SDL_RENDERER_ACCELERATED);&#10;        if (!m_sdlRenderer) {&#10;            spdlog::warn(&quot;Failed to create accelerated renderer, trying software...&quot;);&#10;            m_sdlRenderer = SDL_CreateRenderer(m_window, -1, SDL_RENDERER_SOFTWARE);&#10;            if (!m_sdlRenderer) {&#10;                SDL_DestroyWindow(m_window);&#10;                SDL_Quit();&#10;                throw std::runtime_error(&quot;Failed to create SDL renderer: &quot; + std::string(SDL_GetError()));&#10;            }&#10;        }&#10;    }&#10;    &#10;    spdlog::info(&quot;Created SDL2 renderer successfully&quot;);&#10;&#10;    if (!m_renderer-&gt;Initialize(m_sdlRenderer)) {&#10;        SDL_DestroyRenderer(m_sdlRenderer);&#10;        SDL_DestroyWindow(m_window);&#10;        SDL_Quit();&#10;        throw std::runtime_error(&quot;Failed to initialize renderer&quot;);&#10;    }&#10;&#10;    InitializeImGui();&#10;    &#10;    spdlog::info(&quot;Application initialized successfully&quot;);&#10;&#10;    RenderFrame();&#10;    SDL_ShowWindow(m_window);&#10;}&#10;&#10;Application::~Application() {&#10;    spdlog::info(&quot;Shutting down application...&quot;);&#10;    &#10;    m_running = false;&#10;    &#10;    if (ImGui::GetCurrentContext()) {&#10;        ImGui_ImplSDLRenderer2_Shutdown();&#10;        ImGui_ImplSDL2_Shutdown();&#10;        ImGui::DestroyContext();&#10;    }&#10;    &#10;    m_renderer-&gt;Cleanup();&#10;    &#10;    if (m_sdlRenderer) {&#10;        SDL_DestroyRenderer(m_sdlRenderer);&#10;        m_sdlRenderer = nullptr;&#10;    }&#10;    &#10;    if (m_window) {&#10;        SDL_DestroyWindow(m_window);&#10;        m_window = nullptr;&#10;    }&#10;    &#10;    SDL_Quit();&#10;    spdlog::info(&quot;Application shutdown complete&quot;);&#10;}&#10;&#10;void Application::Run() {&#10;    while (m_running) {&#10;        ProcessEvents();&#10;        Update();&#10;        RenderFrame();&#10;    }&#10;}&#10;&#10;void Application::InitializeImGui() {&#10;    IMGUI_CHECKVERSION();&#10;    ImGui::CreateContext();&#10;    ImGuiIO&amp; io = ImGui::GetIO();&#10;    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;&#10;    // io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;&#10;    &#10;    ImGui::StyleColorsDark();&#10;    &#10;    ImGui_ImplSDL2_InitForSDLRenderer(m_window, m_sdlRenderer);&#10;    ImGui_ImplSDLRenderer2_Init(m_sdlRenderer);&#10;    &#10;    spdlog::info(&quot;ImGui initialized with SDL2 renderer&quot;);&#10;}&#10;&#10;void Application::ProcessEvents() noexcept {&#10;    SDL_Event event;&#10;    while (SDL_PollEvent(&amp;event)) {&#10;        ImGui_ImplSDL2_ProcessEvent(&amp;event);&#10;        &#10;        if (event.type == SDL_QUIT || (event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym == SDLK_ESCAPE)) {&#10;            m_running = false;&#10;            return;&#10;        }&#10;        &#10;        if (!ImGui::GetIO().WantCaptureMouse &amp;&amp; !ImGui::GetIO().WantCaptureKeyboard) {&#10;            m_eventHandler-&gt;HandleEvent(event, m_diagramData-&gt;GetCamera(), m_diagramData-&gt;GetBlocks());&#10;        }&#10;    }&#10;}&#10;&#10;void Application::Update() noexcept {&#10;}&#10;&#10;void Application::RenderFrame() noexcept {&#10;&#10;    ImGui_ImplSDLRenderer2_NewFrame();&#10;    ImGui_ImplSDL2_NewFrame();&#10;    ImGui::NewFrame();&#10;    &#10;    RenderUI();&#10;    &#10;    m_renderer-&gt;Clear();&#10;    m_renderer-&gt;DrawGrid(m_diagramData-&gt;GetCamera());&#10;    m_renderer-&gt;DrawBlocks(m_diagramData-&gt;GetBlocks(), m_diagramData-&gt;GetCamera());&#10;    &#10;    ImGui::Render();&#10;    ImGui_ImplSDLRenderer2_RenderDrawData(ImGui::GetDrawData(), m_sdlRenderer);&#10;    &#10;    SDL_RenderPresent(m_sdlRenderer);&#10;}&#10;&#10;void Application::RenderUI() noexcept {&#10;&#10;    if (ImGui::BeginMainMenuBar()) {&#10;        if (ImGui::BeginMenu(&quot;File&quot;)) {&#10;            if (ImGui::MenuItem(&quot;New&quot;, &quot;Ctrl+N&quot;)) {}&#10;            if (ImGui::MenuItem(&quot;Open&quot;, &quot;Ctrl+O&quot;)) {}&#10;            if (ImGui::MenuItem(&quot;Save&quot;, &quot;Ctrl+S&quot;)) {}&#10;            ImGui::Separator();&#10;            if (ImGui::MenuItem(&quot;Exit&quot;, &quot;Alt+F4&quot;)) {&#10;                m_running = false;&#10;            }&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        if (ImGui::BeginMenu(&quot;Edit&quot;)) {&#10;            if (ImGui::MenuItem(&quot;Undo&quot;, &quot;Ctrl+Z&quot;)) {}&#10;            if (ImGui::MenuItem(&quot;Redo&quot;, &quot;Ctrl+Y&quot;)) {}&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        if (ImGui::BeginMenu(&quot;View&quot;)) {&#10;            ImGui::MenuItem(&quot;Properties&quot;, nullptr, &amp;m_showProperties);&#10;            ImGui::MenuItem(&quot;Demo&quot;, nullptr, &amp;m_showDemo);&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        ImGui::EndMainMenuBar();&#10;    }&#10;    &#10;    if (m_showProperties) {&#10;        RenderPropertiesPanel();&#10;    }&#10;    &#10;    if (m_showDemo) {&#10;        ImGui::ShowDemoWindow(&amp;m_showDemo);&#10;    }&#10;}&#10;&#10;void Application::RenderPropertiesPanel() noexcept {&#10;    ImGui::Begin(&quot;Properties&quot;, &amp;m_showProperties);&#10;    &#10;    auto&amp; blocks = m_diagramData-&gt;GetBlocks();&#10;    auto&amp; camera = m_diagramData-&gt;GetCamera();&#10;    &#10;    ImGui::Text(&quot;Camera Position: (%.1f, %.1f)&quot;, camera.position.x, camera.position.y);&#10;    ImGui::Text(&quot;Blocks Count: %zu&quot;, blocks.size());&#10;    &#10;    if (ImGui::Button(&quot;Add Block&quot;)) {&#10;        blocks.emplace_back();&#10;        auto&amp; newBlock = blocks.back();&#10;        newBlock.position = {100.0f + blocks.size() * 150.0f, 100.0f};&#10;        newBlock.label = &quot;Block &quot; + std::to_string(blocks.size());&#10;    }&#10;    &#10;    ImGui::Separator();&#10;    &#10;    for (size_t i = 0; i &lt; blocks.size(); ++i) {&#10;        auto&amp; block = blocks[i];&#10;        ImGui::PushID(static_cast&lt;int&gt;(i));&#10;        &#10;        if (ImGui::CollapsingHeader((&quot;Block &quot; + std::to_string(i + 1)).c_str())) {&#10;            char labelBuffer[256];&#10;            strncpy(labelBuffer, block.label.c_str(), sizeof(labelBuffer) - 1);&#10;            labelBuffer[sizeof(labelBuffer) - 1] = '\0';&#10;            if (ImGui::InputText(&quot;Label&quot;, labelBuffer, sizeof(labelBuffer))) {&#10;                block.label = labelBuffer;&#10;            }&#10;            ImGui::DragFloat2(&quot;Position&quot;, &amp;block.position.x, 1.0f);&#10;            ImGui::DragFloat2(&quot;Size&quot;, &amp;block.size.x, 1.0f, 10.0f, 500.0f);&#10;            ImGui::ColorEdit4(&quot;Color&quot;, &amp;block.color.x);&#10;            &#10;            const char* typeNames[] = {&quot;Start&quot;, &quot;Process&quot;, &quot;Decision&quot;, &quot;End&quot;};&#10;            int currentType = static_cast&lt;int&gt;(block.type);&#10;            if (ImGui::Combo(&quot;Type&quot;, &amp;currentType, typeNames, 4)) {&#10;                block.type = static_cast&lt;Diagram::BlockType&gt;(currentType);&#10;            }&#10;            &#10;            if (ImGui::Button(&quot;Delete&quot;)) {&#10;                blocks.erase(blocks.begin() + i);&#10;                ImGui::PopID();&#10;                break;&#10;            }&#10;        }&#10;        &#10;        ImGui::PopID();&#10;    }&#10;    &#10;    ImGui::End();&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;Application.hpp&quot;&#10;#include &quot;Renderer.hpp&quot;&#10;#include &quot;EventHandler.hpp&quot;&#10;#include &quot;DiagramData.hpp&quot;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;spdlog/spdlog.h&gt;&#10;#include &lt;imgui.h&gt;&#10;#include &lt;imgui_impl_sdl2.h&gt;&#10;#include &lt;imgui_impl_sdlrenderer2.h&gt;&#10;&#10;Application::Application() : m_eventHandler(std::make_unique&lt;EventHandler&gt;()), m_diagramData(std::make_unique&lt;DiagramData&gt;()) {&#10;    spdlog::info(&quot;Initializing application...&quot;);&#10;&#10;    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS) != 0)&#10;        throw std::runtime_error(&quot;SDL_Init error: &quot; + std::string(SDL_GetError()));&#10;    &#10;    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, &quot;0&quot;);&#10;    SDL_SetHint(SDL_HINT_RENDER_VSYNC, &quot;0&quot;);&#10;    SDL_SetHint(SDL_HINT_RENDER_DRIVER, &quot;opengl&quot;);&#10;    SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, &quot;0&quot;);&#10;&#10;    int displayIndex = 0;&#10;    int mouseX, mouseY;&#10;    SDL_GetGlobalMouseState(&amp;mouseX, &amp;mouseY);&#10;    int numDisplays = SDL_GetNumVideoDisplays();&#10;    &#10;    for (int i = 0; i &lt; numDisplays; i++) {&#10;        SDL_Rect displayBounds;&#10;        if (SDL_GetDisplayBounds(i, &amp;displayBounds) == 0 &amp;&amp;&#10;            mouseX &gt;= displayBounds.x &amp;&amp; mouseX &lt; displayBounds.x + displayBounds.w &amp;&amp;&#10;            mouseY &gt;= displayBounds.y &amp;&amp; mouseY &lt; displayBounds.y + displayBounds.h) {&#10;            displayIndex = i;&#10;            break;&#10;        }&#10;    }&#10;&#10;    m_window = SDL_CreateWindow(&quot;Negentropy - Diagram Editor&quot;,&#10;                                SDL_WINDOWPOS_CENTERED_DISPLAY(displayIndex), &#10;                                SDL_WINDOWPOS_CENTERED_DISPLAY(displayIndex), 1280, 720,&#10;                                SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);&#10;    if (!m_window) {&#10;        SDL_Quit();&#10;        throw std::runtime_error(&quot;SDL_CreateWindow error: &quot; + std::string(SDL_GetError()));&#10;    }&#10;&#10;    if (!m_renderer.Initialize(m_window)) {&#10;        SDL_DestroyWindow(m_window);&#10;        SDL_Quit();&#10;        throw std::runtime_error(&quot;Failed to initialize renderer&quot;);&#10;    }&#10;&#10;    InitializeImGui();&#10;    &#10;    spdlog::info(&quot;Application initialized successfully&quot;);&#10;&#10;    RenderFrame();&#10;    SDL_Delay(16);&#10;    SDL_ShowWindow(m_window);&#10;}&#10;&#10;Application::~Application() {&#10;    spdlog::info(&quot;Shutting down application...&quot;);&#10;    &#10;    m_running = false;&#10;    &#10;    ImGui_ImplSDLRenderer2_Shutdown();&#10;    ImGui_ImplSDL2_Shutdown();&#10;    ImGui::DestroyContext();&#10;    &#10;    m_renderer.Cleanup();&#10;    &#10;    if (m_window) {&#10;        SDL_DestroyWindow(m_window);&#10;        m_window = nullptr;&#10;    }&#10;    &#10;    SDL_Quit();&#10;    spdlog::info(&quot;Application shutdown complete&quot;);&#10;}&#10;&#10;void Application::Run() {&#10;    while (m_running) {&#10;        ProcessEvents();&#10;        Update();&#10;        RenderFrame();&#10;    }&#10;}&#10;&#10;void Application::InitializeImGui() {&#10;    IMGUI_CHECKVERSION();&#10;    ImGui::CreateContext();&#10;    ImGuiIO&amp; io = ImGui::GetIO();&#10;    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;&#10;    // io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;&#10;    &#10;    ImGui::StyleColorsDark();&#10;    &#10;    ImGui_ImplSDL2_InitForSDLRenderer(m_window, m_renderer.GetSDLRenderer());&#10;    ImGui_ImplSDLRenderer2_Init(m_renderer.GetSDLRenderer());&#10;    &#10;    spdlog::info(&quot;ImGui initialized with SDL2 renderer&quot;);&#10;}&#10;&#10;void Application::ProcessEvents() noexcept {&#10;    SDL_Event event;&#10;    while (SDL_PollEvent(&amp;event)) {&#10;        ImGui_ImplSDL2_ProcessEvent(&amp;event);&#10;        &#10;        if (event.type == SDL_QUIT || (event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym == SDLK_ESCAPE)) {&#10;            m_running = false;&#10;            return;&#10;        }&#10;        &#10;        if (!ImGui::GetIO().WantCaptureMouse &amp;&amp; !ImGui::GetIO().WantCaptureKeyboard) {&#10;            m_eventHandler-&gt;HandleEvent(event, m_diagramData-&gt;GetCamera(), m_diagramData-&gt;GetBlocks());&#10;        }&#10;    }&#10;}&#10;&#10;void Application::Update() noexcept {&#10;}&#10;&#10;void Application::RenderFrame() noexcept {&#10;&#10;    ImGui_ImplSDLRenderer2_NewFrame();&#10;    ImGui_ImplSDL2_NewFrame();&#10;    ImGui::NewFrame();&#10;    &#10;    RenderUI();&#10;    &#10;    m_renderer.Clear();&#10;    m_renderer.DrawGrid(m_diagramData-&gt;GetCamera());&#10;    m_renderer.DrawBlocks(m_diagramData-&gt;GetBlocks(), m_diagramData-&gt;GetCamera());&#10;    &#10;    ImGui::Render();&#10;    ImGui_ImplSDLRenderer2_RenderDrawData(ImGui::GetDrawData(), m_renderer.GetSDLRenderer());&#10;    &#10;    m_renderer.Present();&#10;}&#10;&#10;void Application::RenderUI() noexcept {&#10;&#10;    if (ImGui::BeginMainMenuBar()) {&#10;        if (ImGui::BeginMenu(&quot;File&quot;)) {&#10;            if (ImGui::MenuItem(&quot;New&quot;, &quot;Ctrl+N&quot;)) {}&#10;            if (ImGui::MenuItem(&quot;Open&quot;, &quot;Ctrl+O&quot;)) {}&#10;            if (ImGui::MenuItem(&quot;Save&quot;, &quot;Ctrl+S&quot;)) {}&#10;            ImGui::Separator();&#10;            if (ImGui::MenuItem(&quot;Exit&quot;, &quot;Alt+F4&quot;)) {&#10;                m_running = false;&#10;            }&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        if (ImGui::BeginMenu(&quot;Edit&quot;)) {&#10;            if (ImGui::MenuItem(&quot;Undo&quot;, &quot;Ctrl+Z&quot;)) {}&#10;            if (ImGui::MenuItem(&quot;Redo&quot;, &quot;Ctrl+Y&quot;)) {}&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        if (ImGui::BeginMenu(&quot;View&quot;)) {&#10;            ImGui::MenuItem(&quot;Properties&quot;, nullptr, &amp;m_showProperties);&#10;            ImGui::MenuItem(&quot;Demo&quot;, nullptr, &amp;m_showDemo);&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        ImGui::EndMainMenuBar();&#10;    }&#10;    &#10;    if (m_showProperties) {&#10;        RenderPropertiesPanel();&#10;    }&#10;    &#10;    if (m_showDemo) {&#10;        ImGui::ShowDemoWindow(&amp;m_showDemo);&#10;    }&#10;}&#10;&#10;void Application::RenderPropertiesPanel() noexcept {&#10;    ImGui::Begin(&quot;Properties&quot;, &amp;m_showProperties);&#10;    &#10;    auto&amp; blocks = m_diagramData-&gt;GetBlocks();&#10;    auto&amp; camera = m_diagramData-&gt;GetCamera();&#10;    &#10;    ImGui::Text(&quot;Camera Position: (%.1f, %.1f)&quot;, camera.position.x, camera.position.y);&#10;    ImGui::Text(&quot;Blocks Count: %zu&quot;, blocks.size());&#10;    &#10;    if (ImGui::Button(&quot;Add Block&quot;)) {&#10;        blocks.emplace_back();&#10;        auto&amp; newBlock = blocks.back();&#10;        newBlock.position = {100.0f + blocks.size() * 150.0f, 100.0f};&#10;        newBlock.label = &quot;Block &quot; + std::to_string(blocks.size());&#10;    }&#10;    &#10;    ImGui::Separator();&#10;    &#10;    for (size_t i = 0; i &lt; blocks.size(); ++i) {&#10;        auto&amp; block = blocks[i];&#10;        ImGui::PushID(static_cast&lt;int&gt;(i));&#10;        &#10;        if (ImGui::CollapsingHeader((&quot;Block &quot; + std::to_string(i + 1)).c_str())) {&#10;            char labelBuffer[256];&#10;            strncpy(labelBuffer, block.label.c_str(), sizeof(labelBuffer) - 1);&#10;            labelBuffer[sizeof(labelBuffer) - 1] = '\0';&#10;            if (ImGui::InputText(&quot;Label&quot;, labelBuffer, sizeof(labelBuffer))) {&#10;                block.label = labelBuffer;&#10;            }&#10;            ImGui::DragFloat2(&quot;Position&quot;, &amp;block.position.x, 1.0f);&#10;            ImGui::DragFloat2(&quot;Size&quot;, &amp;block.size.x, 1.0f, 10.0f, 500.0f);&#10;            ImGui::ColorEdit4(&quot;Color&quot;, &amp;block.color.x);&#10;            &#10;            const char* typeNames[] = {&quot;Start&quot;, &quot;Process&quot;, &quot;Decision&quot;, &quot;End&quot;};&#10;            int currentType = static_cast&lt;int&gt;(block.type);&#10;            if (ImGui::Combo(&quot;Type&quot;, &amp;currentType, typeNames, 4)) {&#10;                block.type = static_cast&lt;Diagram::BlockType&gt;(currentType);&#10;            }&#10;            &#10;            if (ImGui::Button(&quot;Delete&quot;)) {&#10;                blocks.erase(blocks.begin() + i);&#10;                ImGui::PopID();&#10;                break;&#10;            }&#10;        }&#10;        &#10;        ImGui::PopID();&#10;    }&#10;    &#10;    ImGui::End();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Main/Application.hpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Main/Application.hpp" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;SDL.h&gt;&#10;#include &lt;memory&gt;&#10;&#10;class Renderer;&#10;class EventHandler;&#10;class DiagramData;&#10;&#10;class Application {&#10;public:&#10;    Application();&#10;    ~Application();&#10;&#10;    Application(const Application&amp;) = delete;&#10;    Application&amp; operator=(const Application&amp;) = delete;&#10;    Application(Application&amp;&amp;) = delete;&#10;    Application&amp; operator=(Application&amp;&amp;) = delete;&#10;&#10;    void Run();&#10;&#10;private:&#10;    void InitializeImGui();&#10;    void ProcessEvents() noexcept;&#10;    void Update() noexcept;&#10;    void RenderFrame() noexcept;&#10;    void RenderUI() noexcept;&#10;    void RenderPropertiesPanel() noexcept;&#10;&#10;    bool m_running = true;&#10;    SDL_Window* m_window = nullptr;&#10;    SDL_Renderer* m_sdlRenderer = nullptr;&#10;    &#10;    bool m_showProperties = true;&#10;    bool m_showDemo = false;&#10;&#10;    std::unique_ptr&lt;Renderer&gt; m_renderer;&#10;    std::unique_ptr&lt;EventHandler&gt; m_eventHandler;&#10;    std::unique_ptr&lt;DiagramData&gt; m_diagramData;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;SDL.h&gt;&#10;#include &lt;memory&gt;&#10;#include &quot;Renderer.hpp&quot;&#10;#include &quot;EventHandler.hpp&quot;&#10;#include &quot;DiagramData.hpp&quot;&#10;&#10;class Application {&#10;public:&#10;    Application();&#10;    ~Application();&#10;&#10;    Application(const Application&amp;) = delete;&#10;    Application&amp; operator=(const Application&amp;) = delete;&#10;    Application(Application&amp;&amp;) = delete;&#10;    Application&amp; operator=(Application&amp;&amp;) = delete;&#10;&#10;    void Run();&#10;&#10;private:&#10;    void InitializeImGui();&#10;    void ProcessEvents() noexcept;&#10;    void Update() noexcept;&#10;    void RenderFrame() noexcept;&#10;    void RenderUI() noexcept;&#10;    void RenderPropertiesPanel() noexcept;&#10;&#10;    bool m_running = true;&#10;    SDL_Window* m_window = nullptr;&#10;    Renderer m_renderer;&#10;    std::unique_ptr&lt;EventHandler&gt; m_eventHandler;&#10;    std::unique_ptr&lt;DiagramData&gt; m_diagramData;&#10;&#10;    bool m_showProperties = true;&#10;    bool m_showDemo = false;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Main/Renderer.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Main/Renderer.cpp" />
              <option name="originalContent" value="#include &quot;Renderer.hpp&quot;&#10;#include &quot;../Diagram/Block.hpp&quot;&#10;#include &quot;../Diagram/Camera.hpp&quot;&#10;#include &lt;glm/vec2.hpp&gt;&#10;#include &lt;glm/vec4.hpp&gt;&#10;#ifdef TRACY_ENABLE&#10;#include &lt;tracy/Tracy.hpp&gt;&#10;#endif&#10;&#10;bool Renderer::Initialize(SDL_Renderer* renderer) noexcept {&#10;    m_renderer = renderer;&#10;    if (!m_renderer) return false;&#10;    SDL_SetRenderDrawBlendMode(m_renderer, SDL_BLENDMODE_BLEND);&#10;    return true;&#10;}&#10;&#10;void Renderer::Clear() noexcept {&#10;#ifdef TRACY_ENABLE&#10;    ZoneScoped;&#10;#endif&#10;    SDL_SetRenderDrawColor(m_renderer, 30, 30, 30, 255);&#10;    SDL_RenderClear(m_renderer);&#10;}&#10;&#10;void Renderer::DrawGrid(const Diagram::Camera&amp; camera) noexcept {&#10;#ifdef TRACY_ENABLE&#10;    ZoneScoped;&#10;#endif&#10;    SDL_SetRenderDrawColor(m_renderer, 50, 50, 50, 255);&#10;    constexpr int step = 50;&#10;    int w, h;&#10;    SDL_GetRendererOutputSize(m_renderer, &amp;w, &amp;h);&#10;    &#10;    const int offsetX = -static_cast&lt;int&gt;(static_cast&lt;int&gt;(camera.position.x) % step);&#10;    const int offsetY = -static_cast&lt;int&gt;(static_cast&lt;int&gt;(camera.position.y) % step);&#10;    &#10;    for (int x = offsetX; x &lt; w; x += step)&#10;        SDL_RenderDrawLine(m_renderer, x, 0, x, h);&#10;    for (int y = offsetY; y &lt; h; y += step)&#10;        SDL_RenderDrawLine(m_renderer, 0, y, w, y);&#10;}&#10;&#10;void Renderer::DrawBlocks(const std::vector&lt;Diagram::Block&gt;&amp; blocks, const Diagram::Camera&amp; camera) noexcept {&#10;#ifdef TRACY_ENABLE&#10;    ZoneScoped;&#10;#endif&#10;    for (const auto&amp; block : blocks) {&#10;        const auto screenPos = camera.WorldToScreen(block.position);&#10;        const SDL_FRect rect = {screenPos.x, screenPos.y, block.size.x, block.size.y};&#10;        &#10;        const auto r = static_cast&lt;Uint8&gt;(block.color.r * 255.0f);&#10;        const auto g = static_cast&lt;Uint8&gt;(block.color.g * 255.0f);&#10;        const auto b = static_cast&lt;Uint8&gt;(block.color.b * 255.0f);&#10;        const auto a = static_cast&lt;Uint8&gt;(block.color.a * 255.0f);&#10;        &#10;        SDL_SetRenderDrawColor(m_renderer, r, g, b, a);&#10;        SDL_RenderFillRectF(m_renderer, &amp;rect);&#10;        SDL_SetRenderDrawColor(m_renderer, 255, 255, 255, 255);&#10;        SDL_RenderDrawRectF(m_renderer, &amp;rect);&#10;    }&#10;}&#10;&#10;void Renderer::Present() noexcept {&#10;    SDL_RenderPresent(m_renderer);&#10;}&#10;&#10;void Renderer::Cleanup() noexcept {&#10;    m_renderer = nullptr;&#10;}&#10;&#10;SDL_Renderer* Renderer::GetSDLRenderer() const noexcept {&#10;    return m_renderer;&#10;}" />
              <option name="updatedContent" value="#include &quot;Renderer.hpp&quot;&#10;#include &quot;../Diagram/Block.hpp&quot;&#10;#include &quot;../Diagram/Camera.hpp&quot;&#10;#include &lt;glm/vec2.hpp&gt;&#10;#include &lt;glm/vec4.hpp&gt;&#10;#ifdef TRACY_ENABLE&#10;#include &lt;tracy/Tracy.hpp&gt;&#10;#endif&#10;&#10;bool Renderer::Initialize(SDL_Window* window) noexcept {&#10;    m_renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);&#10;    if (!m_renderer) {&#10;        m_renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);&#10;        if (!m_renderer) {&#10;            m_renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_SOFTWARE);&#10;            if (!m_renderer) return false;&#10;        }&#10;    }&#10;    SDL_SetRenderDrawBlendMode(m_renderer, SDL_BLENDMODE_BLEND);&#10;    return true;&#10;}&#10;&#10;void Renderer::Clear() noexcept {&#10;#ifdef TRACY_ENABLE&#10;    ZoneScoped;&#10;#endif&#10;    SDL_SetRenderDrawColor(m_renderer, 30, 30, 30, 255);&#10;    SDL_RenderClear(m_renderer);&#10;}&#10;&#10;void Renderer::DrawGrid(const Diagram::Camera&amp; camera) noexcept {&#10;#ifdef TRACY_ENABLE&#10;    ZoneScoped;&#10;#endif&#10;    SDL_SetRenderDrawColor(m_renderer, 50, 50, 50, 255);&#10;    constexpr int step = 50;&#10;    int w, h;&#10;    SDL_GetRendererOutputSize(m_renderer, &amp;w, &amp;h);&#10;    &#10;    const int offsetX = -static_cast&lt;int&gt;(static_cast&lt;int&gt;(camera.position.x) % step);&#10;    const int offsetY = -static_cast&lt;int&gt;(static_cast&lt;int&gt;(camera.position.y) % step);&#10;    &#10;    for (int x = offsetX; x &lt; w; x += step)&#10;        SDL_RenderDrawLine(m_renderer, x, 0, x, h);&#10;    for (int y = offsetY; y &lt; h; y += step)&#10;        SDL_RenderDrawLine(m_renderer, 0, y, w, y);&#10;}&#10;&#10;void Renderer::DrawBlocks(const std::vector&lt;Diagram::Block&gt;&amp; blocks, const Diagram::Camera&amp; camera) noexcept {&#10;#ifdef TRACY_ENABLE&#10;    ZoneScoped;&#10;#endif&#10;    for (const auto&amp; block : blocks) {&#10;        const auto screenPos = camera.WorldToScreen(block.position);&#10;        const SDL_FRect rect = {screenPos.x, screenPos.y, block.size.x, block.size.y};&#10;        &#10;        const auto r = static_cast&lt;Uint8&gt;(block.color.r * 255.0f);&#10;        const auto g = static_cast&lt;Uint8&gt;(block.color.g * 255.0f);&#10;        const auto b = static_cast&lt;Uint8&gt;(block.color.b * 255.0f);&#10;        const auto a = static_cast&lt;Uint8&gt;(block.color.a * 255.0f);&#10;        &#10;        SDL_SetRenderDrawColor(m_renderer, r, g, b, a);&#10;        SDL_RenderFillRectF(m_renderer, &amp;rect);&#10;        SDL_SetRenderDrawColor(m_renderer, 255, 255, 255, 255);&#10;        SDL_RenderDrawRectF(m_renderer, &amp;rect);&#10;    }&#10;}&#10;&#10;void Renderer::Present() noexcept {&#10;    SDL_RenderPresent(m_renderer);&#10;}&#10;&#10;void Renderer::Cleanup() noexcept {&#10;    m_renderer = nullptr;&#10;}&#10;&#10;SDL_Renderer* Renderer::GetSDLRenderer() const noexcept {&#10;    return m_renderer;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Main/Renderer.hpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Main/Renderer.hpp" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;SDL.h&gt;&#10;#include &lt;vector&gt;&#10;&#10;namespace Diagram {&#10;    struct Block;&#10;    struct Camera;&#10;}&#10;&#10;class Renderer {&#10;public:&#10;    Renderer() = default;&#10;    ~Renderer() = default;&#10;&#10;    Renderer(const Renderer&amp;) = delete;&#10;    Renderer&amp; operator=(const Renderer&amp;) = delete;&#10;    Renderer(Renderer&amp;&amp;) = delete;&#10;    Renderer&amp; operator=(Renderer&amp;&amp;) = delete;&#10;&#10;    [[nodiscard]] bool Initialize(SDL_Renderer* renderer) noexcept;&#10;    void Clear() noexcept;&#10;    void DrawGrid(const Diagram::Camera&amp; camera) noexcept;&#10;    void DrawBlocks(const std::vector&lt;Diagram::Block&gt;&amp; blocks, const Diagram::Camera&amp; camera) noexcept;&#10;    void Present() noexcept;&#10;    void Cleanup() noexcept;&#10;    &#10;    [[nodiscard]] SDL_Renderer* GetSDLRenderer() const noexcept;&#10;&#10;private:&#10;    SDL_Renderer* m_renderer = nullptr;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;SDL.h&gt;&#10;#include &lt;vector&gt;&#10;&#10;namespace Diagram {&#10;    struct Block;&#10;    struct Camera;&#10;}&#10;&#10;class Renderer {&#10;public:&#10;    Renderer() = default;&#10;    ~Renderer() = default;&#10;&#10;    Renderer(const Renderer&amp;) = delete;&#10;    Renderer&amp; operator=(const Renderer&amp;) = delete;&#10;    Renderer(Renderer&amp;&amp;) = delete;&#10;    Renderer&amp; operator=(Renderer&amp;&amp;) = delete;&#10;&#10;    [[nodiscard]] bool Initialize(SDL_Window* window) noexcept;&#10;    void Clear() noexcept;&#10;    void DrawGrid(const Diagram::Camera&amp; camera) noexcept;&#10;    void DrawBlocks(const std::vector&lt;Diagram::Block&gt;&amp; blocks, const Diagram::Camera&amp; camera) noexcept;&#10;    void Present() noexcept;&#10;    void Cleanup() noexcept;&#10;    &#10;    [[nodiscard]] SDL_Renderer* GetSDLRenderer() const noexcept;&#10;&#10;private:&#10;    SDL_Renderer* m_renderer = nullptr;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>