<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Core/Diagram/Block.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Diagram/Block.cpp" />
              <option name="originalContent" value="#include &quot;Block.hpp&quot;&#10;#include &quot;Camera.hpp&quot;&#10;#include &lt;cstring&gt;&#10;&#10;#include &lt;imgui.h&gt;&#10;&#10;namespace Diagram {&#10;    bool Block::HandleEvent(const SDL_Event&amp; event, const Camera&amp; camera, glm::vec2 screenSize) noexcept {&#10;        if (event.type == SDL_MOUSEBUTTONDOWN &amp;&amp; event.button.button == SDL_BUTTON_LEFT) {&#10;            const glm::vec2 worldPos = camera.ScreenToWorld({static_cast&lt;float&gt;(event.button.x), static_cast&lt;float&gt;(event.button.y)}, screenSize);&#10;            const bool contains = (data.position.x &lt;= worldPos.x &amp;&amp; worldPos.x &lt;= data.position.x + data.size.x &amp;&amp;&#10;                                   data.position.y &lt;= worldPos.y &amp;&amp; worldPos.y &lt;= data.position.y + data.size.y);&#10;            if (contains) {&#10;                m_dragging = true;&#10;                m_dragOffset = worldPos - data.position;&#10;                return true;&#10;            }&#10;        }&#10;        else if (event.type == SDL_MOUSEBUTTONUP &amp;&amp; event.button.button == SDL_BUTTON_LEFT) {&#10;            if (m_dragging) {&#10;                m_dragging = false;&#10;                return true;&#10;            }&#10;        }&#10;        else if (event.type == SDL_MOUSEMOTION &amp;&amp; m_dragging) {&#10;            const glm::vec2 worldPos = camera.ScreenToWorld({static_cast&lt;float&gt;(event.motion.x), static_cast&lt;float&gt;(event.motion.y)}, screenSize);&#10;            data.position = worldPos - m_dragOffset;&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    void Block::Render(SDL_Renderer* renderer, const Camera&amp; camera, glm::vec2 screenSize) const noexcept {&#10;        const auto screenPos = camera.WorldToScreen(data.position, screenSize);&#10;        const SDL_FRect rect = {screenPos.x, screenPos.y, data.size.x * camera.data.zoom, data.size.y * camera.data.zoom};&#10;&#10;        const auto bgR = static_cast&lt;Uint8&gt;(data.backgroundColor.r * 255.0f);&#10;        const auto bgG = static_cast&lt;Uint8&gt;(data.backgroundColor.g * 255.0f);&#10;        const auto bgB = static_cast&lt;Uint8&gt;(data.backgroundColor.b * 255.0f);&#10;        const auto bgA = static_cast&lt;Uint8&gt;(data.backgroundColor.a * 255.0f);&#10;&#10;        SDL_SetRenderDrawColor(renderer, bgR, bgG, bgB, bgA);&#10;        SDL_RenderFillRectF(renderer, &amp;rect);&#10;&#10;        const auto borderR = static_cast&lt;Uint8&gt;(data.borderColor.r * 255.0f);&#10;        const auto borderG = static_cast&lt;Uint8&gt;(data.borderColor.g * 255.0f);&#10;        const auto borderB = static_cast&lt;Uint8&gt;(data.borderColor.b * 255.0f);&#10;        const auto borderA = static_cast&lt;Uint8&gt;(data.borderColor.a * 255.0f);&#10;        &#10;        SDL_SetRenderDrawColor(renderer, borderR, borderG, borderB, borderA);&#10;        SDL_RenderDrawRectF(renderer, &amp;rect);&#10;    }&#10;&#10;    void Block::xml_serialize(pugi::xml_node&amp; node) const {&#10;        XML::auto_serialize(data, node);&#10;    }&#10;&#10;    void Block::xml_deserialize(const pugi::xml_node&amp; node) {&#10;        XML::auto_deserialize(data, node);&#10;    }&#10;&#10;    std::string Block::GetDisplayName() const noexcept {&#10;        return data.label.empty() ? &quot;Block&quot; : data.label;&#10;    }&#10;&#10;&#10;    void Block::RenderUI(const int id) noexcept {&#10;        ImGui::PushID(id);&#10;        &#10;        char labelBuffer[256];&#10;        std::strncpy(labelBuffer, data.label.c_str(), sizeof(labelBuffer) - 1);&#10;        labelBuffer[sizeof(labelBuffer) - 1] = '\0';&#10;        if (ImGui::InputText(&quot;Label&quot;, labelBuffer, sizeof(labelBuffer))) {&#10;            data.label = labelBuffer;&#10;        }&#10;        &#10;        ImGui::DragFloat2(&quot;Position&quot;, &amp;data.position.x, 1.0f);&#10;        ImGui::DragFloat2(&quot;Size&quot;, &amp;data.size.x, 1.0f, 10.0f, 500.0f);&#10;        ImGui::ColorEdit4(&quot;Background&quot;, &amp;data.backgroundColor.x);&#10;        ImGui::ColorEdit4(&quot;Border&quot;, &amp;data.borderColor.x);&#10;        &#10;        const char* typeNames[] = {&quot;Start&quot;, &quot;Process&quot;, &quot;Decision&quot;, &quot;End&quot;};&#10;        int currentType = static_cast&lt;int&gt;(data.type);&#10;        if (ImGui::Combo(&quot;Type&quot;, &amp;currentType, typeNames, 4)) {&#10;            data.type = static_cast&lt;Type&gt;(currentType);&#10;        }&#10;        &#10;        ImGui::PopID();&#10;    }&#10;}" />
              <option name="updatedContent" value="#include &quot;Block.hpp&quot;&#10;#include &quot;Camera.hpp&quot;&#10;#include &lt;cstring&gt;&#10;&#10;#include &lt;imgui.h&gt;&#10;&#10;namespace Diagram {&#10;    bool Block::HandleEvent(const SDL_Event&amp; event, const Camera&amp; camera, glm::vec2 screenSize) noexcept {&#10;        if (event.type == SDL_MOUSEBUTTONDOWN &amp;&amp; event.button.button == SDL_BUTTON_LEFT) {&#10;            const glm::vec2 worldPos = camera.ScreenToWorld({static_cast&lt;float&gt;(event.button.x), static_cast&lt;float&gt;(event.button.y)}, screenSize);&#10;            const bool contains = (data.position.x &lt;= worldPos.x &amp;&amp; worldPos.x &lt;= data.position.x + data.size.x &amp;&amp;&#10;                                   data.position.y &lt;= worldPos.y &amp;&amp; worldPos.y &lt;= data.position.y + data.size.y);&#10;            if (contains) {&#10;                m_dragging = true;&#10;                m_dragOffset = worldPos - data.position;&#10;                return true;&#10;            }&#10;        }&#10;        else if (event.type == SDL_MOUSEBUTTONUP &amp;&amp; event.button.button == SDL_BUTTON_LEFT) {&#10;            if (m_dragging) {&#10;                m_dragging = false;&#10;                return true;&#10;            }&#10;        }&#10;        else if (event.type == SDL_MOUSEMOTION &amp;&amp; m_dragging) {&#10;            const glm::vec2 worldPos = camera.ScreenToWorld({static_cast&lt;float&gt;(event.motion.x), static_cast&lt;float&gt;(event.motion.y)}, screenSize);&#10;            data.position = worldPos - m_dragOffset;&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    void Block::Render(SDL_Renderer* renderer, const Camera&amp; camera, glm::vec2 screenSize) const noexcept {&#10;        const auto screenPos = camera.WorldToScreen(data.position, screenSize);&#10;        const SDL_FRect rect = {screenPos.x, screenPos.y, data.size.x * camera.data.zoom, data.size.y * camera.data.zoom};&#10;&#10;        const auto bgR = static_cast&lt;Uint8&gt;(data.backgroundColor.r * 255.0f);&#10;        const auto bgG = static_cast&lt;Uint8&gt;(data.backgroundColor.g * 255.0f);&#10;        const auto bgB = static_cast&lt;Uint8&gt;(data.backgroundColor.b * 255.0f);&#10;        const auto bgA = static_cast&lt;Uint8&gt;(data.backgroundColor.a * 255.0f);&#10;&#10;        SDL_SetRenderDrawColor(renderer, bgR, bgG, bgB, bgA);&#10;        SDL_RenderFillRectF(renderer, &amp;rect);&#10;&#10;        const auto borderR = static_cast&lt;Uint8&gt;(data.borderColor.r * 255.0f);&#10;        const auto borderG = static_cast&lt;Uint8&gt;(data.borderColor.g * 255.0f);&#10;        const auto borderB = static_cast&lt;Uint8&gt;(data.borderColor.b * 255.0f);&#10;        const auto borderA = static_cast&lt;Uint8&gt;(data.borderColor.a * 255.0f);&#10;        &#10;        SDL_SetRenderDrawColor(renderer, borderR, borderG, borderB, borderA);&#10;        SDL_RenderDrawRectF(renderer, &amp;rect);&#10;    }&#10;&#10;    void Block::xml_serialize(pugi::xml_node&amp; node) const {&#10;        XML::auto_serialize(data, node);&#10;    }&#10;&#10;    void Block::xml_deserialize(const pugi::xml_node&amp; node) {&#10;        XML::auto_deserialize(data, node);&#10;    }&#10;&#10;    std::string Block::GetDisplayName() const noexcept {&#10;        return data.label.empty() ? &quot;Block&quot; : data.label;&#10;    }&#10;&#10;&#10;    void Block::RenderUI(int id) noexcept {&#10;        ImGui::PushID(id);&#10;        &#10;        char labelBuffer[256];&#10;        std::strncpy(labelBuffer, data.label.c_str(), sizeof(labelBuffer) - 1);&#10;        labelBuffer[sizeof(labelBuffer) - 1] = '\0';&#10;        if (ImGui::InputText(&quot;Label&quot;, labelBuffer, sizeof(labelBuffer))) {&#10;            data.label = labelBuffer;&#10;        }&#10;        &#10;        ImGui::DragFloat2(&quot;Position&quot;, &amp;data.position.x, 1.0f);&#10;        ImGui::DragFloat2(&quot;Size&quot;, &amp;data.size.x, 1.0f, 10.0f, 500.0f);&#10;        ImGui::ColorEdit4(&quot;Background&quot;, &amp;data.backgroundColor.x);&#10;        ImGui::ColorEdit4(&quot;Border&quot;, &amp;data.borderColor.x);&#10;        &#10;        const char* typeNames[] = {&quot;Start&quot;, &quot;Process&quot;, &quot;Decision&quot;, &quot;End&quot;};&#10;        int currentType = static_cast&lt;int&gt;(data.type);&#10;        if (ImGui::Combo(&quot;Type&quot;, &amp;currentType, typeNames, 4)) {&#10;            data.type = static_cast&lt;Type&gt;(currentType);&#10;        }&#10;        &#10;        ImGui::PopID();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Diagram/Component.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Diagram/Component.cpp" />
              <option name="originalContent" value="#include &quot;Component.hpp&quot;&#10;#include &quot;Block.hpp&quot;&#10;#include &lt;imgui.h&gt;&#10;#include &lt;algorithm&gt;&#10;&#10;namespace Diagram {&#10;    ComponentBase* ComponentBase::s_selected = nullptr;&#10;&#10;    void ComponentBase::RenderComponentTree(std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        if (!ImGui::Begin(&quot;Component Tree&quot;)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        auto hierarchy = BuildHierarchy(components);&#10;        if (hierarchy) {&#10;            RenderTreeNode(*hierarchy, &amp;components);&#10;        }&#10;&#10;        ImGui::End();&#10;    }&#10;&#10;    void ComponentBase::RenderComponentEditor() noexcept {&#10;        if (!ImGui::Begin(&quot;Component Editor&quot;, nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (!s_selected) {&#10;            ImGui::TextDisabled(&quot;No component selected&quot;);&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (auto* block = dynamic_cast&lt;Block*&gt;(s_selected)) {&#10;            block-&gt;RenderUI(0);&#10;        } else {&#10;            ImGui::TextDisabled(&quot;Unknown component type&quot;);&#10;        }&#10;&#10;        ImGui::End();&#10;    }&#10;&#10;    void ComponentBase::RenderTreeNode(const ComponentBase::TreeNode&amp; node, std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;* components) noexcept {&#10;        ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_DefaultOpen;&#10;        &#10;        if (node.children.empty()) {&#10;            flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;&#10;        }&#10;        &#10;        if (s_selected == node.component) {&#10;            flags |= ImGuiTreeNodeFlags_Selected;&#10;        }&#10;&#10;        bool nodeOpen = ImGui::TreeNodeEx(node.name.c_str(), flags);&#10;        &#10;        if (ImGui::IsItemClicked() &amp;&amp; node.component) {&#10;            Select(node.component);&#10;        }&#10;&#10;        // Drag &amp; drop only for components (not for root node)&#10;        if (node.component) {&#10;            if (ImGui::BeginDragDropSource()) {&#10;                ImGui::SetDragDropPayload(&quot;COMPONENT_DND&quot;, &amp;node.component, sizeof(void*));&#10;                ImGui::Text(&quot;Moving: %s&quot;, node.name.c_str());&#10;                ImGui::EndDragDropSource();&#10;            }&#10;        }&#10;&#10;        if (nodeOpen &amp;&amp; !node.children.empty()) {&#10;            for (auto&amp; child : node.children) {&#10;                RenderTreeNode(*child, components);&#10;                &#10;                // Drop target for reorder&#10;                if (child-&gt;component &amp;&amp; ImGui::BeginDragDropTarget()) {&#10;                    if (const auto* payload = ImGui::AcceptDragDropPayload(&quot;COMPONENT_DND&quot;)) {&#10;                        auto* draggedComp = *static_cast&lt;ComponentBase**&gt;(payload-&gt;Data);&#10;                        if (components &amp;&amp; draggedComp != child-&gt;component) {&#10;                            auto draggedIt = std::find_if(components-&gt;begin(), components-&gt;end(),&#10;                                [draggedComp](const auto&amp; c) { return c.get() == draggedComp; });&#10;                            auto targetIt = std::find_if(components-&gt;begin(), components-&gt;end(),&#10;                                [&amp;child](const auto&amp; c) { return c.get() == child-&gt;component; });&#10;                            &#10;                            if (draggedIt != components-&gt;end() &amp;&amp; targetIt != components-&gt;end()) {&#10;                                std::iter_swap(draggedIt, targetIt);&#10;                            }&#10;                        }&#10;                    }&#10;                    ImGui::EndDragDropTarget();&#10;                }&#10;            }&#10;            ImGui::TreePop();&#10;        }&#10;    }&#10;&#10;    std::unique_ptr&lt;ComponentBase::TreeNode&gt; ComponentBase::BuildHierarchy(const std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        auto root = std::make_unique&lt;TreeNode&gt;(&quot;Scene&quot;);&#10;        &#10;        for (const auto&amp; component : components) {&#10;            auto componentNode = std::make_unique&lt;TreeNode&gt;(&#10;                component-&gt;GetDisplayName(),&#10;                component.get()&#10;            );&#10;            root-&gt;children.push_back(std::move(componentNode));&#10;        }&#10;        &#10;        return root;&#10;    }&#10;}" />
              <option name="updatedContent" value="#include &quot;Component.hpp&quot;&#10;#include &quot;Block.hpp&quot;&#10;#include &quot;imgui.h&quot;&#10;#include &lt;algorithm&gt;&#10;&#10;namespace Diagram {&#10;    ComponentBase* ComponentBase::s_selected = nullptr;&#10;&#10;    void ComponentBase::RenderComponentTree(std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        if (!ImGui::Begin(&quot;Component Tree&quot;)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        auto hierarchy = BuildHierarchy(components);&#10;        if (hierarchy) {&#10;            RenderTreeNode(*hierarchy, &amp;components);&#10;        }&#10;&#10;        ImGui::End();&#10;    }&#10;&#10;    void ComponentBase::RenderComponentEditor() noexcept {&#10;        if (!ImGui::Begin(&quot;Component Editor&quot;, nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (!s_selected) {&#10;            ImGui::TextDisabled(&quot;No component selected&quot;);&#10;            ImGui::End();&#10;            return;&#10;        }&#10;&#10;        if (auto* block = dynamic_cast&lt;Block*&gt;(s_selected)) {&#10;            block-&gt;RenderUI(0);&#10;        } else {&#10;            ImGui::TextDisabled(&quot;Unknown component type&quot;);&#10;        }&#10;&#10;        ImGui::End();&#10;    }&#10;&#10;    void ComponentBase::RenderTreeNode(const ComponentBase::TreeNode&amp; node, std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;* components) noexcept {&#10;        ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_DefaultOpen;&#10;        &#10;        if (node.children.empty()) {&#10;            flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;&#10;        }&#10;        &#10;        if (s_selected == node.component) {&#10;            flags |= ImGuiTreeNodeFlags_Selected;&#10;        }&#10;&#10;        bool nodeOpen = ImGui::TreeNodeEx(node.name.c_str(), flags);&#10;        &#10;        if (ImGui::IsItemClicked() &amp;&amp; node.component) {&#10;            Select(node.component);&#10;        }&#10;&#10;        // Drag &amp; drop only for components (not for root node)&#10;        if (node.component) {&#10;            if (ImGui::BeginDragDropSource()) {&#10;                ImGui::SetDragDropPayload(&quot;COMPONENT_DND&quot;, &amp;node.component, sizeof(void*));&#10;                ImGui::Text(&quot;Moving: %s&quot;, node.name.c_str());&#10;                ImGui::EndDragDropSource();&#10;            }&#10;        }&#10;&#10;        if (nodeOpen &amp;&amp; !node.children.empty()) {&#10;            for (auto&amp; child : node.children) {&#10;                RenderTreeNode(*child, components);&#10;                &#10;                // Drop target for reorder&#10;                if (child-&gt;component &amp;&amp; ImGui::BeginDragDropTarget()) {&#10;                    if (const auto* payload = ImGui::AcceptDragDropPayload(&quot;COMPONENT_DND&quot;)) {&#10;                        auto* draggedComp = *static_cast&lt;ComponentBase**&gt;(payload-&gt;Data);&#10;                        if (components &amp;&amp; draggedComp != child-&gt;component) {&#10;                            auto draggedIt = std::find_if(components-&gt;begin(), components-&gt;end(),&#10;                                [draggedComp](const auto&amp; c) { return c.get() == draggedComp; });&#10;                            auto targetIt = std::find_if(components-&gt;begin(), components-&gt;end(),&#10;                                [&amp;child](const auto&amp; c) { return c.get() == child-&gt;component; });&#10;                            &#10;                            if (draggedIt != components-&gt;end() &amp;&amp; targetIt != components-&gt;end()) {&#10;                                std::iter_swap(draggedIt, targetIt);&#10;                            }&#10;                        }&#10;                    }&#10;                    ImGui::EndDragDropTarget();&#10;                }&#10;            }&#10;            ImGui::TreePop();&#10;        }&#10;    }&#10;&#10;    std::unique_ptr&lt;ComponentBase::TreeNode&gt; ComponentBase::BuildHierarchy(const std::vector&lt;std::unique_ptr&lt;ComponentBase&gt;&gt;&amp; components) noexcept {&#10;        auto root = std::make_unique&lt;TreeNode&gt;(&quot;Scene&quot;);&#10;        &#10;        for (const auto&amp; component : components) {&#10;            auto componentNode = std::make_unique&lt;TreeNode&gt;(&#10;                component-&gt;GetDisplayName(),&#10;                component.get()&#10;            );&#10;            root-&gt;children.push_back(std::move(componentNode));&#10;        }&#10;        &#10;        return root;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Main/Application.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Main/Application.cpp" />
              <option name="originalContent" value="#include &quot;Application.hpp&quot;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;spdlog/spdlog.h&gt;&#10;#include &lt;imgui.h&gt;&#10;#include &lt;imgui_impl_sdl2.h&gt;&#10;#include &lt;imgui_impl_sdlrenderer2.h&gt;&#10;#include &lt;filesystem&gt;&#10;#include &quot;../Utils/Path.hpp&quot;&#10;#include &quot;../Utils/Notification.hpp&quot;&#10;&#10;namespace fs = std::filesystem;&#10;&#10;Application::Application() {&#10;    InitSDL();&#10;    CreateWindow();&#10;&#10;    if (!m_renderer.Initialize(m_window)) {&#10;        SDL_DestroyWindow(m_window);&#10;        SDL_Quit();&#10;        throw std::runtime_error(&quot;Failed to initialize renderer&quot;);&#10;    }&#10;&#10;    InitializeImGui();&#10;    &#10;    spdlog::info(&quot;Application initialized successfully&quot;);&#10;&#10;    m_currentFilePath = (Utils::GetWorkspacePath() / &quot;Default.xml&quot;).string();&#10;    m_diagramData.Load(m_currentFilePath);&#10;&#10;    RefreshWorkspaceFiles();&#10;    SDL_ShowWindow(m_window);&#10;}&#10;&#10;Application::~Application() {&#10;    spdlog::info(&quot;Shutting down application...&quot;);&#10;    &#10;    ImGui_ImplSDLRenderer2_Shutdown();&#10;    ImGui_ImplSDL2_Shutdown();&#10;    ImGui::DestroyContext();&#10;&#10;    if (m_window) {&#10;        SDL_DestroyWindow(m_window);&#10;        m_window = nullptr;&#10;    }&#10;    &#10;    SDL_Quit();&#10;    spdlog::info(&quot;Application shutdown complete&quot;);&#10;}&#10;&#10;void Application::Run() {&#10;    while (m_running) {&#10;        ImGui_ImplSDLRenderer2_NewFrame();&#10;        ImGui_ImplSDL2_NewFrame();&#10;        ImGui::NewFrame();&#10;&#10;        ProcessEvents();&#10;        RenderFrame();&#10;    }&#10;}&#10;&#10;void Application::InitializeImGui() const {&#10;    IMGUI_CHECKVERSION();&#10;    ImGui::CreateContext();&#10;    ImGuiIO&amp; io = ImGui::GetIO();&#10;    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;&#10;&#10;    DarkStyle();&#10;    SetupFont();&#10;    &#10;    ImGui_ImplSDL2_InitForSDLRenderer(m_window, m_renderer.GetSDLRenderer());&#10;    ImGui_ImplSDLRenderer2_Init(m_renderer.GetSDLRenderer());&#10;&#10;    spdlog::info(&quot;ImGui initialized&quot;);&#10;}&#10;&#10;void Application::ProcessEvents() noexcept {&#10;    SDL_Event event;&#10;    while (SDL_PollEvent(&amp;event)) {&#10;        ImGui_ImplSDL2_ProcessEvent(&amp;event);&#10;        &#10;        if (event.type == SDL_QUIT || (event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym == SDLK_ESCAPE)) {&#10;            m_running = false;&#10;            return;&#10;        }&#10;        &#10;        if (event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym == SDLK_s &amp;&amp; (event.key.keysym.mod &amp; KMOD_CTRL)) {&#10;            SaveDiagram();&#10;            return;&#10;        }&#10;        &#10;        bool shouldProcessEvent = true;&#10;        if (event.type == SDL_MOUSEBUTTONDOWN || event.type == SDL_MOUSEBUTTONUP || event.type == SDL_MOUSEMOTION || event.type == SDL_MOUSEWHEEL) {&#10;            shouldProcessEvent = !ImGui::GetIO().WantCaptureMouse;&#10;        } else if (event.type == SDL_KEYDOWN || event.type == SDL_KEYUP || event.type == SDL_TEXTINPUT) {&#10;            shouldProcessEvent = !ImGui::GetIO().WantCaptureKeyboard;&#10;        }&#10;&#10;        if (shouldProcessEvent) {&#10;            int w, h;&#10;            SDL_GetWindowSize(m_window, &amp;w, &amp;h);&#10;            const glm::vec2 screenSize{static_cast&lt;float&gt;(w), static_cast&lt;float&gt;(h)};&#10;            EventHandler::HandleEvent(event, m_diagramData.GetCamera(), m_diagramData.GetComponents(), screenSize);&#10;        }&#10;    }&#10;}&#10;&#10;&#10;void Application::RenderFrame() noexcept {&#10;    RenderUI();&#10;    &#10;    m_renderer.Clear();&#10;    m_renderer.DrawGrid(m_diagramData.GetCamera(), m_diagramData.GetGrid());&#10;    m_renderer.DrawComponents(m_diagramData.GetComponents(), m_diagramData.GetCamera());&#10;&#10;    ImGui::Render();&#10;    ImGui_ImplSDLRenderer2_RenderDrawData(ImGui::GetDrawData(), m_renderer.GetSDLRenderer());&#10;&#10;    m_renderer.Present();&#10;}&#10;&#10;void Application::RenderUI() noexcept {&#10;    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(8.0f, 3.0f));&#10;    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(6.0f, 3.0f));&#10;    &#10;    if (ImGui::BeginMainMenuBar()) {&#10;        if (ImGui::BeginMenu(&quot;File&quot;)) {&#10;            if (ImGui::BeginMenu(&quot;Load&quot;)) {&#10;                for (const auto&amp; file : m_workspaceFiles) {&#10;                    if (ImGui::MenuItem(file.c_str())) {&#10;                        m_currentFilePath = (Utils::GetWorkspacePath() / file).string();&#10;                        m_diagramData.Load(m_currentFilePath);&#10;                    }&#10;                }&#10;                ImGui::EndMenu();&#10;            }&#10;            if (ImGui::MenuItem(&quot;Save&quot;, &quot;Ctrl+S&quot;)) {&#10;                SaveDiagram();&#10;            }&#10;            ImGui::Separator();&#10;            if (ImGui::MenuItem(&quot;Exit&quot;, &quot;Alt+F4&quot;)) {&#10;                m_running = false;&#10;            }&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        if (ImGui::BeginMenu(&quot;Edit&quot;)) {&#10;            if (ImGui::MenuItem(&quot;Undo&quot;, &quot;Ctrl+Z&quot;)) {}&#10;            if (ImGui::MenuItem(&quot;Redo&quot;, &quot;Ctrl+Y&quot;)) {}&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        if (ImGui::BeginMenu(&quot;View&quot;)) {&#10;            ImGui::MenuItem(&quot;Properties&quot;, nullptr, &amp;m_showProperties);&#10;            ImGui::MenuItem(&quot;Component Tree&quot;, nullptr, &amp;m_showComponentTree);&#10;            ImGui::MenuItem(&quot;Component Editor&quot;, nullptr, &amp;m_showComponentEditor);&#10;            ImGui::MenuItem(&quot;Demo&quot;, nullptr, &amp;m_showDemo);&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        ImGui::EndMainMenuBar();&#10;    }&#10;    &#10;    ImGui::PopStyleVar(2);&#10;    &#10;    if (m_showProperties) {&#10;        RenderPropertiesPanel();&#10;    }&#10;    &#10;    if (m_showComponentTree) {&#10;        Diagram::ComponentBase::RenderComponentTree(m_diagramData.GetComponents());&#10;    }&#10;    &#10;    if (m_showComponentEditor) {&#10;        Diagram::ComponentBase::RenderComponentEditor();&#10;    }&#10;    &#10;    if (m_showDemo) {&#10;        ImGui::ShowDemoWindow(&amp;m_showDemo);&#10;    }&#10;&#10;    Notify::Render();&#10;}&#10;&#10;void Application::RenderPropertiesPanel() noexcept {&#10;    ImGui::Begin(&quot;Properties&quot;, &amp;m_showProperties);&#10;    &#10;    auto&amp; components = m_diagramData.GetComponents();&#10;    auto&amp; camera = m_diagramData.GetCamera();&#10;    &#10;    size_t blockCount = m_diagramData.GetComponentsOfType&lt;Diagram::Block&gt;().size();&#10;    &#10;    ImGui::Text(&quot;Camera: (%.1f, %.1f) Zoom: %.2f&quot;, camera.data.position.x, camera.data.position.y, camera.data.zoom);&#10;    ImGui::Text(&quot;Blocks: %zu&quot;, blockCount);&#10;    &#10;    if (ImGui::Button(&quot;Add Block&quot;)) {&#10;        auto newBlock = std::make_unique&lt;Diagram::Block&gt;();&#10;        newBlock-&gt;data.position = {100.0f + static_cast&lt;float&gt;(blockCount + 1) * 150.0f, 100.0f};&#10;        newBlock-&gt;data.label = &quot;Block &quot; + std::to_string(blockCount + 1);&#10;        components.push_back(std::move(newBlock));&#10;    }&#10;    &#10;    ImGui::End();&#10;}&#10;&#10;void Application::SaveDiagram() noexcept {&#10;    if (!m_currentFilePath.empty()) {&#10;        m_diagramData.Save(m_currentFilePath);&#10;    } else {&#10;        Notify::Error(&quot;No file is currently open to save.&quot;);&#10;    }&#10;}&#10;&#10;void Application::RefreshWorkspaceFiles() {&#10;    m_workspaceFiles.clear();&#10;    const auto path = Utils::GetWorkspacePath();&#10;    for (const auto &amp; entry : fs::directory_iterator(path)) {&#10;        if (entry.is_regular_file() &amp;&amp; entry.path().extension() == &quot;.xml&quot;) {&#10;            m_workspaceFiles.push_back(entry.path().filename().string());&#10;        }&#10;    }&#10;}&#10;&#10;void Application::InitSDL() {&#10;    spdlog::info(&quot;Initializing SDL...&quot;);&#10;    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS) != 0)&#10;        throw std::runtime_error(&quot;SDL_Init error: &quot; + std::string(SDL_GetError()));&#10;&#10;    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, &quot;0&quot;);&#10;    SDL_SetHint(SDL_HINT_RENDER_VSYNC, &quot;0&quot;);&#10;    SDL_SetHint(SDL_HINT_RENDER_DRIVER, &quot;opengl&quot;);&#10;    SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, &quot;0&quot;);&#10;}&#10;&#10;void Application::DarkStyle() noexcept {&#10;    auto&amp; style = ImGui::GetStyle();&#10;    auto&amp; colors = style.Colors;&#10;    &#10;    colors[ImGuiCol_Text]                = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);&#10;    colors[ImGuiCol_TextDisabled]        = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);&#10;    colors[ImGuiCol_WindowBg]            = ImVec4(0.09f, 0.09f, 0.10f, 1.00f);&#10;    colors[ImGuiCol_ChildBg]             = ImVec4(0.09f, 0.09f, 0.10f, 1.00f);&#10;    colors[ImGuiCol_PopupBg]             = ImVec4(0.12f, 0.12f, 0.14f, 0.98f);&#10;    colors[ImGuiCol_Border]              = ImVec4(0.25f, 0.25f, 0.26f, 1.00f);&#10;    colors[ImGuiCol_BorderShadow]        = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);&#10;    colors[ImGuiCol_FrameBg]             = ImVec4(0.15f, 0.15f, 0.17f, 1.00f);&#10;    colors[ImGuiCol_FrameBgHovered]      = ImVec4(0.19f, 0.19f, 0.21f, 1.00f);&#10;    colors[ImGuiCol_FrameBgActive]       = ImVec4(0.22f, 0.22f, 0.24f, 1.00f);&#10;    colors[ImGuiCol_TitleBg]             = ImVec4(0.07f, 0.07f, 0.08f, 1.00f);&#10;    colors[ImGuiCol_TitleBgActive]       = ImVec4(0.09f, 0.09f, 0.10f, 1.00f);&#10;    colors[ImGuiCol_TitleBgCollapsed]    = ImVec4(0.07f, 0.07f, 0.08f, 1.00f);&#10;    colors[ImGuiCol_MenuBarBg]           = ImVec4(0.09f, 0.09f, 0.10f, 1.00f);&#10;    colors[ImGuiCol_ScrollbarBg]         = ImVec4(0.09f, 0.09f, 0.10f, 1.00f);&#10;    colors[ImGuiCol_ScrollbarGrab]       = ImVec4(0.22f, 0.22f, 0.22f, 1.00f);&#10;    colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.28f, 0.28f, 0.28f, 1.00f);&#10;    colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.34f, 0.34f, 0.34f, 1.00f);&#10;    colors[ImGuiCol_CheckMark]           = ImVec4(0.00f, 0.47f, 0.84f, 1.00f);&#10;    colors[ImGuiCol_SliderGrab]          = ImVec4(0.00f, 0.47f, 0.84f, 1.00f);&#10;    colors[ImGuiCol_SliderGrabActive]    = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);&#10;    colors[ImGuiCol_Button]              = ImVec4(0.13f, 0.13f, 0.15f, 1.00f);&#10;    colors[ImGuiCol_ButtonHovered]       = ImVec4(0.17f, 0.17f, 0.19f, 1.00f);&#10;    colors[ImGuiCol_ButtonActive]        = ImVec4(0.00f, 0.47f, 0.84f, 1.00f);&#10;    colors[ImGuiCol_Header]              = ImVec4(0.13f, 0.13f, 0.15f, 1.00f);&#10;    colors[ImGuiCol_HeaderHovered]       = ImVec4(0.17f, 0.17f, 0.19f, 1.00f);&#10;    colors[ImGuiCol_HeaderActive]        = ImVec4(0.00f, 0.47f, 0.84f, 1.00f);&#10;    colors[ImGuiCol_Separator]           = ImVec4(0.22f, 0.22f, 0.22f, 1.00f);&#10;    colors[ImGuiCol_SeparatorHovered]    = ImVec4(0.26f, 0.26f, 0.26f, 1.00f);&#10;    colors[ImGuiCol_SeparatorActive]     = ImVec4(0.00f, 0.47f, 0.84f, 1.00f);&#10;    colors[ImGuiCol_ResizeGrip]          = ImVec4(0.00f, 0.47f, 0.84f, 0.20f);&#10;    colors[ImGuiCol_ResizeGripHovered]   = ImVec4(0.00f, 0.47f, 0.84f, 0.67f);&#10;    colors[ImGuiCol_ResizeGripActive]    = ImVec4(0.00f, 0.47f, 0.84f, 0.95f);&#10;    colors[ImGuiCol_Tab]                 = ImVec4(0.07f, 0.07f, 0.08f, 1.00f);&#10;    colors[ImGuiCol_TabHovered]          = ImVec4(0.17f, 0.17f, 0.19f, 1.00f);&#10;    colors[ImGuiCol_TabActive]           = ImVec4(0.13f, 0.13f, 0.15f, 1.00f);&#10;    colors[ImGuiCol_TabUnfocused]        = ImVec4(0.07f, 0.07f, 0.08f, 1.00f);&#10;    colors[ImGuiCol_TabUnfocusedActive]  = ImVec4(0.11f, 0.11f, 0.13f, 1.00f);&#10;    colors[ImGuiCol_PlotLines]           = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);&#10;    colors[ImGuiCol_PlotLinesHovered]    = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);&#10;    colors[ImGuiCol_PlotHistogram]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);&#10;    colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);&#10;    colors[ImGuiCol_TableHeaderBg]       = ImVec4(0.13f, 0.13f, 0.15f, 1.00f);&#10;    colors[ImGuiCol_TableBorderStrong]   = ImVec4(0.25f, 0.25f, 0.26f, 1.00f);&#10;    colors[ImGuiCol_TableBorderLight]    = ImVec4(0.18f, 0.18f, 0.18f, 1.00f);&#10;    colors[ImGuiCol_TableRowBg]          = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);&#10;    colors[ImGuiCol_TableRowBgAlt]       = ImVec4(1.00f, 1.00f, 1.00f, 0.04f);&#10;    colors[ImGuiCol_TextSelectedBg]      = ImVec4(0.00f, 0.47f, 0.84f, 0.35f);&#10;    colors[ImGuiCol_DragDropTarget]      = ImVec4(1.00f, 0.80f, 0.00f, 0.90f);&#10;    colors[ImGuiCol_NavHighlight]        = ImVec4(0.00f, 0.47f, 0.84f, 1.00f);&#10;    colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);&#10;    colors[ImGuiCol_NavWindowingDimBg]   = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);&#10;    colors[ImGuiCol_ModalWindowDimBg]    = ImVec4(0.00f, 0.00f, 0.00f, 0.50f);&#10;&#10;    // Compact VS Code Style Settings&#10;    style.WindowPadding        = ImVec2(5.0f, 5.0f);&#10;    style.FramePadding         = ImVec2(6.0f, 3.0f);&#10;    style.CellPadding          = ImVec2(3.0f, 2.0f);&#10;    style.ItemSpacing          = ImVec2(5.0f, 3.0f);&#10;    style.ItemInnerSpacing     = ImVec2(3.0f, 2.0f);&#10;    style.TouchExtraPadding    = ImVec2(0.0f, 0.0f);&#10;&#10;&#10;    style.IndentSpacing        = 12.0f;&#10;    style.ScrollbarSize        = 12.0f;&#10;    style.GrabMinSize          = 8.0f;&#10;&#10;    // Borders&#10;    style.WindowBorderSize     = 0.0f;&#10;    style.ChildBorderSize      = 0.0f;&#10;    style.PopupBorderSize      = 0.0f;&#10;    style.FrameBorderSize      = 0.0f;&#10;    style.TabBorderSize        = 0.0f;&#10;&#10;    // Rounding&#10;    style.WindowRounding       = 2.0f;&#10;    style.ChildRounding        = 4.0f;&#10;    style.FrameRounding        = 2.0f;&#10;    style.PopupRounding        = 4.0f;&#10;    style.ScrollbarRounding    = 9.0f;&#10;    style.GrabRounding         = 2.0f;&#10;    style.LogSliderDeadzone    = 4.0f;&#10;    style.TabRounding          = 4.0f;&#10;&#10;    // Alignment&#10;    style.WindowTitleAlign     = ImVec2(0.00f, 0.50f);&#10;    style.WindowMenuButtonPosition = ImGuiDir_Left;&#10;    style.ColorButtonPosition = ImGuiDir_Right;&#10;    style.ButtonTextAlign      = ImVec2(0.50f, 0.50f);&#10;    style.SelectableTextAlign  = ImVec2(0.00f, 0.00f);&#10;&#10;    // Safe Area Padding&#10;    style.DisplaySafeAreaPadding = ImVec2(3.0f, 3.0f);&#10;}&#10;&#10;void Application::SetupFont() noexcept {&#10;    ImGuiIO&amp; io = ImGui::GetIO();&#10;    &#10;    const char* fontPaths[] = {&#10;        &quot;/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf&quot;,&#10;        &quot;/usr/share/fonts/TTF/arial.ttf&quot;,&#10;        &quot;/System/Library/Fonts/Helvetica.ttc&quot;,&#10;        &quot;/Windows/Fonts/arial.ttf&quot;,&#10;        &quot;/Windows/Fonts/segoeui.ttf&quot;&#10;    };&#10;    &#10;    for (const char* fontPath : fontPaths) {&#10;        if (std::filesystem::exists(fontPath)) {&#10;            ImFontConfig config;&#10;            config.OversampleH = 3;&#10;            config.OversampleV = 2;&#10;            config.PixelSnapH = true;&#10;            io.Fonts-&gt;AddFontFromFileTTF(fontPath, 12.0f, &amp;config);&#10;            return;&#10;        }&#10;    }&#10;    &#10;    ImFontConfig config;&#10;    config.SizePixels = 14.0f;&#10;    config.OversampleH = 3;&#10;    config.OversampleV = 2;&#10;    config.PixelSnapH = true;&#10;    io.Fonts-&gt;AddFontDefault(&amp;config);&#10;}&#10;&#10;void Application::CreateWindow() {&#10;    spdlog::info(&quot;Creating window...&quot;);&#10;    int displayIndex = 0;&#10;    int mouseX, mouseY;&#10;    SDL_GetGlobalMouseState(&amp;mouseX, &amp;mouseY);&#10;    int numDisplays = SDL_GetNumVideoDisplays();&#10;&#10;    for (int i = 0; i &lt; numDisplays; i++) {&#10;        SDL_Rect displayBounds;&#10;        if (SDL_GetDisplayBounds(i, &amp;displayBounds) == 0 &amp;&amp;&#10;            mouseX &gt;= displayBounds.x &amp;&amp; mouseX &lt; displayBounds.x + displayBounds.w &amp;&amp;&#10;            mouseY &gt;= displayBounds.y &amp;&amp; mouseY &lt; displayBounds.y + displayBounds.h) {&#10;            displayIndex = i;&#10;            break;&#10;        }&#10;    }&#10;&#10;    m_window = SDL_CreateWindow(&quot;Negentropy - Diagram Editor&quot;,&#10;                                SDL_WINDOWPOS_CENTERED_DISPLAY(displayIndex),&#10;                                SDL_WINDOWPOS_CENTERED_DISPLAY(displayIndex), 1280, 720,&#10;                                SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);&#10;    if (!m_window) {&#10;        SDL_Quit();&#10;        throw std::runtime_error(&quot;SDL_CreateWindow error: &quot; + std::string(SDL_GetError()));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;Application.hpp&quot;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;spdlog/spdlog.h&gt;&#10;#include &lt;imgui.h&gt;&#10;#include &lt;imgui_impl_sdl2.h&gt;&#10;#include &lt;imgui_impl_sdlrenderer2.h&gt;&#10;#include &lt;filesystem&gt;&#10;#include &quot;../Utils/Path.hpp&quot;&#10;#include &quot;../Utils/Notification.hpp&quot;&#10;&#10;namespace fs = std::filesystem;&#10;&#10;Application::Application() {&#10;    InitSDL();&#10;    CreateWindow();&#10;&#10;    if (!m_renderer.Initialize(m_window)) {&#10;        SDL_DestroyWindow(m_window);&#10;        SDL_Quit();&#10;        throw std::runtime_error(&quot;Failed to initialize renderer&quot;);&#10;    }&#10;&#10;    InitializeImGui();&#10;    &#10;    spdlog::info(&quot;Application initialized successfully&quot;);&#10;&#10;    m_currentFilePath = (Utils::GetWorkspacePath() / &quot;Default.xml&quot;).string();&#10;    m_diagramData.Load(m_currentFilePath);&#10;&#10;    RefreshWorkspaceFiles();&#10;    SDL_ShowWindow(m_window);&#10;}&#10;&#10;Application::~Application() {&#10;    spdlog::info(&quot;Shutting down application...&quot;);&#10;    &#10;    ImGui_ImplSDLRenderer2_Shutdown();&#10;    ImGui_ImplSDL2_Shutdown();&#10;    ImGui::DestroyContext();&#10;&#10;    if (m_window) {&#10;        SDL_DestroyWindow(m_window);&#10;        m_window = nullptr;&#10;    }&#10;    &#10;    SDL_Quit();&#10;    spdlog::info(&quot;Application shutdown complete&quot;);&#10;}&#10;&#10;void Application::Run() {&#10;    while (m_running) {&#10;        ImGui_ImplSDLRenderer2_NewFrame();&#10;        ImGui_ImplSDL2_NewFrame();&#10;        ImGui::NewFrame();&#10;&#10;        ProcessEvents();&#10;        RenderFrame();&#10;    }&#10;}&#10;&#10;void Application::InitializeImGui() const {&#10;    IMGUI_CHECKVERSION();&#10;    ImGui::CreateContext();&#10;    ImGuiIO&amp; io = ImGui::GetIO();&#10;    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;&#10;&#10;    DarkStyle();&#10;    SetupFont();&#10;    &#10;    ImGui_ImplSDL2_InitForSDLRenderer(m_window, m_renderer.GetSDLRenderer());&#10;    ImGui_ImplSDLRenderer2_Init(m_renderer.GetSDLRenderer());&#10;&#10;    spdlog::info(&quot;ImGui initialized&quot;);&#10;}&#10;&#10;void Application::ProcessEvents() noexcept {&#10;    SDL_Event event;&#10;    while (SDL_PollEvent(&amp;event)) {&#10;        ImGui_ImplSDL2_ProcessEvent(&amp;event);&#10;        &#10;        if (event.type == SDL_QUIT || (event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym == SDLK_ESCAPE)) {&#10;            m_running = false;&#10;            return;&#10;        }&#10;        &#10;        if (event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym == SDLK_s &amp;&amp; (event.key.keysym.mod &amp; KMOD_CTRL)) {&#10;            SaveDiagram();&#10;            return;&#10;        }&#10;&#10;        if (event.type == SDL_KEYDOWN &amp;&amp; event.key.keysym.sym == SDLK_F1) {&#10;            m_diagramData.AddBlock(true, m_window);&#10;            return;&#10;        }&#10;        &#10;        bool shouldProcessEvent = true;&#10;        if (event.type == SDL_MOUSEBUTTONDOWN || event.type == SDL_MOUSEBUTTONUP || event.type == SDL_MOUSEMOTION || event.type == SDL_MOUSEWHEEL) {&#10;            shouldProcessEvent = !ImGui::GetIO().WantCaptureMouse;&#10;        } else if (event.type == SDL_KEYDOWN || event.type == SDL_KEYUP || event.type == SDL_TEXTINPUT) {&#10;            shouldProcessEvent = !ImGui::GetIO().WantCaptureKeyboard;&#10;        }&#10;&#10;        if (shouldProcessEvent) {&#10;            int w, h;&#10;            SDL_GetWindowSize(m_window, &amp;w, &amp;h);&#10;            const glm::vec2 screenSize{static_cast&lt;float&gt;(w), static_cast&lt;float&gt;(h)};&#10;            EventHandler::HandleEvent(event, m_diagramData.GetCamera(), m_diagramData.GetComponents(), screenSize);&#10;        }&#10;    }&#10;}&#10;&#10;&#10;void Application::RenderFrame() noexcept {&#10;    RenderUI();&#10;    &#10;    m_renderer.Clear();&#10;    m_renderer.DrawGrid(m_diagramData.GetCamera(), m_diagramData.GetGrid());&#10;    m_renderer.DrawComponents(m_diagramData.GetComponents(), m_diagramData.GetCamera());&#10;&#10;    ImGui::Render();&#10;    ImGui_ImplSDLRenderer2_RenderDrawData(ImGui::GetDrawData(), m_renderer.GetSDLRenderer());&#10;&#10;    m_renderer.Present();&#10;}&#10;&#10;void Application::RenderUI() noexcept {&#10;    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(8.0f, 3.0f));&#10;    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(6.0f, 3.0f));&#10;    &#10;    if (ImGui::BeginMainMenuBar()) {&#10;        if (ImGui::BeginMenu(&quot;File&quot;)) {&#10;            if (ImGui::BeginMenu(&quot;Load&quot;)) {&#10;                for (const auto&amp; file : m_workspaceFiles) {&#10;                    if (ImGui::MenuItem(file.c_str())) {&#10;                        m_currentFilePath = (Utils::GetWorkspacePath() / file).string();&#10;                        m_diagramData.Load(m_currentFilePath);&#10;                    }&#10;                }&#10;                ImGui::EndMenu();&#10;            }&#10;            if (ImGui::MenuItem(&quot;Save&quot;, &quot;Ctrl+S&quot;)) {&#10;                SaveDiagram();&#10;            }&#10;            ImGui::Separator();&#10;            if (ImGui::MenuItem(&quot;Exit&quot;, &quot;Alt+F4&quot;)) {&#10;                m_running = false;&#10;            }&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        if (ImGui::BeginMenu(&quot;Edit&quot;)) {&#10;            if (ImGui::MenuItem(&quot;Undo&quot;, &quot;Ctrl+Z&quot;)) {}&#10;            if (ImGui::MenuItem(&quot;Redo&quot;, &quot;Ctrl+Y&quot;)) {}&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        if (ImGui::BeginMenu(&quot;View&quot;)) {&#10;            ImGui::MenuItem(&quot;Properties&quot;, nullptr, &amp;m_showProperties);&#10;            ImGui::MenuItem(&quot;Component Tree&quot;, nullptr, &amp;m_showComponentTree);&#10;            ImGui::MenuItem(&quot;Component Editor&quot;, nullptr, &amp;m_showComponentEditor);&#10;            ImGui::MenuItem(&quot;Demo&quot;, nullptr, &amp;m_showDemo);&#10;            ImGui::EndMenu();&#10;        }&#10;        &#10;        ImGui::EndMainMenuBar();&#10;    }&#10;    &#10;    ImGui::PopStyleVar(2);&#10;    &#10;    if (m_showProperties) {&#10;        RenderPropertiesPanel();&#10;    }&#10;    &#10;    if (m_showComponentTree) {&#10;        Diagram::ComponentBase::RenderComponentTree(m_diagramData.GetComponents());&#10;    }&#10;    &#10;    if (m_showComponentEditor) {&#10;        Diagram::ComponentBase::RenderComponentEditor();&#10;    }&#10;    &#10;    if (m_showDemo) {&#10;        ImGui::ShowDemoWindow(&amp;m_showDemo);&#10;    }&#10;&#10;    Notify::Render();&#10;}&#10;&#10;void Application::RenderPropertiesPanel() noexcept {&#10;    ImGui::Begin(&quot;Properties&quot;, &amp;m_showProperties);&#10;    &#10;    auto&amp; components = m_diagramData.GetComponents();&#10;    auto&amp; camera = m_diagramData.GetCamera();&#10;    &#10;    size_t blockCount = m_diagramData.GetComponentsOfType&lt;Diagram::Block&gt;().size();&#10;    &#10;    ImGui::Text(&quot;Camera: (%.1f, %.1f) Zoom: %.2f&quot;, camera.data.position.x, camera.data.position.y, camera.data.zoom);&#10;    ImGui::Text(&quot;Blocks: %zu&quot;, blockCount);&#10;    &#10;    if (ImGui::Button(&quot;[F1] Add Block&quot;)) {&#10;        m_diagramData.AddBlock(false, m_window);&#10;    }&#10;    &#10;    ImGui::End();&#10;}&#10;&#10;void Application::SaveDiagram() noexcept {&#10;    if (!m_currentFilePath.empty()) {&#10;        m_diagramData.Save(m_currentFilePath);&#10;    } else {&#10;        Notify::Error(&quot;No file is currently open to save.&quot;);&#10;    }&#10;}&#10;&#10;void Application::RefreshWorkspaceFiles() {&#10;    m_workspaceFiles.clear();&#10;    const auto path = Utils::GetWorkspacePath();&#10;    for (const auto &amp; entry : fs::directory_iterator(path)) {&#10;        if (entry.is_regular_file() &amp;&amp; entry.path().extension() == &quot;.xml&quot;) {&#10;            m_workspaceFiles.push_back(entry.path().filename().string());&#10;        }&#10;    }&#10;}&#10;&#10;void Application::InitSDL() {&#10;    spdlog::info(&quot;Initializing SDL...&quot;);&#10;    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_EVENTS) != 0)&#10;        throw std::runtime_error(&quot;SDL_Init error: &quot; + std::string(SDL_GetError()));&#10;&#10;    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, &quot;0&quot;);&#10;    SDL_SetHint(SDL_HINT_RENDER_VSYNC, &quot;0&quot;);&#10;    SDL_SetHint(SDL_HINT_RENDER_DRIVER, &quot;opengl&quot;);&#10;    SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, &quot;0&quot;);&#10;}&#10;&#10;void Application::DarkStyle() noexcept {&#10;    auto&amp; style = ImGui::GetStyle();&#10;    auto&amp; colors = style.Colors;&#10;    &#10;    colors[ImGuiCol_Text]                = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);&#10;    colors[ImGuiCol_TextDisabled]        = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);&#10;    colors[ImGuiCol_WindowBg]            = ImVec4(0.09f, 0.09f, 0.10f, 1.00f);&#10;    colors[ImGuiCol_ChildBg]             = ImVec4(0.09f, 0.09f, 0.10f, 1.00f);&#10;    colors[ImGuiCol_PopupBg]             = ImVec4(0.12f, 0.12f, 0.14f, 0.98f);&#10;    colors[ImGuiCol_Border]              = ImVec4(0.25f, 0.25f, 0.26f, 1.00f);&#10;    colors[ImGuiCol_BorderShadow]        = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);&#10;    colors[ImGuiCol_FrameBg]             = ImVec4(0.15f, 0.15f, 0.17f, 1.00f);&#10;    colors[ImGuiCol_FrameBgHovered]      = ImVec4(0.19f, 0.19f, 0.21f, 1.00f);&#10;    colors[ImGuiCol_FrameBgActive]       = ImVec4(0.22f, 0.22f, 0.24f, 1.00f);&#10;    colors[ImGuiCol_TitleBg]             = ImVec4(0.07f, 0.07f, 0.08f, 1.00f);&#10;    colors[ImGuiCol_TitleBgActive]       = ImVec4(0.09f, 0.09f, 0.10f, 1.00f);&#10;    colors[ImGuiCol_TitleBgCollapsed]    = ImVec4(0.07f, 0.07f, 0.08f, 1.00f);&#10;    colors[ImGuiCol_MenuBarBg]           = ImVec4(0.09f, 0.09f, 0.10f, 1.00f);&#10;    colors[ImGuiCol_ScrollbarBg]         = ImVec4(0.09f, 0.09f, 0.10f, 1.00f);&#10;    colors[ImGuiCol_ScrollbarGrab]       = ImVec4(0.22f, 0.22f, 0.22f, 1.00f);&#10;    colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.28f, 0.28f, 0.28f, 1.00f);&#10;    colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.34f, 0.34f, 0.34f, 1.00f);&#10;    colors[ImGuiCol_CheckMark]           = ImVec4(0.00f, 0.47f, 0.84f, 1.00f);&#10;    colors[ImGuiCol_SliderGrab]          = ImVec4(0.00f, 0.47f, 0.84f, 1.00f);&#10;    colors[ImGuiCol_SliderGrabActive]    = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);&#10;    colors[ImGuiCol_Button]              = ImVec4(0.13f, 0.13f, 0.15f, 1.00f);&#10;    colors[ImGuiCol_ButtonHovered]       = ImVec4(0.17f, 0.17f, 0.19f, 1.00f);&#10;    colors[ImGuiCol_ButtonActive]        = ImVec4(0.00f, 0.47f, 0.84f, 1.00f);&#10;    colors[ImGuiCol_Header]              = ImVec4(0.13f, 0.13f, 0.15f, 1.00f);&#10;    colors[ImGuiCol_HeaderHovered]       = ImVec4(0.17f, 0.17f, 0.19f, 1.00f);&#10;    colors[ImGuiCol_HeaderActive]        = ImVec4(0.00f, 0.47f, 0.84f, 1.00f);&#10;    colors[ImGuiCol_Separator]           = ImVec4(0.22f, 0.22f, 0.22f, 1.00f);&#10;    colors[ImGuiCol_SeparatorHovered]    = ImVec4(0.26f, 0.26f, 0.26f, 1.00f);&#10;    colors[ImGuiCol_SeparatorActive]     = ImVec4(0.00f, 0.47f, 0.84f, 1.00f);&#10;    colors[ImGuiCol_ResizeGrip]          = ImVec4(0.00f, 0.47f, 0.84f, 0.20f);&#10;    colors[ImGuiCol_ResizeGripHovered]   = ImVec4(0.00f, 0.47f, 0.84f, 0.67f);&#10;    colors[ImGuiCol_ResizeGripActive]    = ImVec4(0.00f, 0.47f, 0.84f, 0.95f);&#10;    colors[ImGuiCol_Tab]                 = ImVec4(0.07f, 0.07f, 0.08f, 1.00f);&#10;    colors[ImGuiCol_TabHovered]          = ImVec4(0.17f, 0.17f, 0.19f, 1.00f);&#10;    colors[ImGuiCol_TabActive]           = ImVec4(0.13f, 0.13f, 0.15f, 1.00f);&#10;    colors[ImGuiCol_TabUnfocused]        = ImVec4(0.07f, 0.07f, 0.08f, 1.00f);&#10;    colors[ImGuiCol_TabUnfocusedActive]  = ImVec4(0.11f, 0.11f, 0.13f, 1.00f);&#10;    colors[ImGuiCol_PlotLines]           = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);&#10;    colors[ImGuiCol_PlotLinesHovered]    = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);&#10;    colors[ImGuiCol_PlotHistogram]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);&#10;    colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);&#10;    colors[ImGuiCol_TableHeaderBg]       = ImVec4(0.13f, 0.13f, 0.15f, 1.00f);&#10;    colors[ImGuiCol_TableBorderStrong]   = ImVec4(0.25f, 0.25f, 0.26f, 1.00f);&#10;    colors[ImGuiCol_TableBorderLight]    = ImVec4(0.18f, 0.18f, 0.18f, 1.00f);&#10;    colors[ImGuiCol_TableRowBg]          = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);&#10;    colors[ImGuiCol_TableRowBgAlt]       = ImVec4(1.00f, 1.00f, 1.00f, 0.04f);&#10;    colors[ImGuiCol_TextSelectedBg]      = ImVec4(0.00f, 0.47f, 0.84f, 0.35f);&#10;    colors[ImGuiCol_DragDropTarget]      = ImVec4(1.00f, 0.80f, 0.00f, 0.90f);&#10;    colors[ImGuiCol_NavHighlight]        = ImVec4(0.00f, 0.47f, 0.84f, 1.00f);&#10;    colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);&#10;    colors[ImGuiCol_NavWindowingDimBg]   = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);&#10;    colors[ImGuiCol_ModalWindowDimBg]    = ImVec4(0.00f, 0.00f, 0.00f, 0.50f);&#10;&#10;    // Compact VS Code Style Settings&#10;    style.WindowPadding        = ImVec2(5.0f, 5.0f);&#10;    style.FramePadding         = ImVec2(6.0f, 3.0f);&#10;    style.CellPadding          = ImVec2(3.0f, 2.0f);&#10;    style.ItemSpacing          = ImVec2(5.0f, 3.0f);&#10;    style.ItemInnerSpacing     = ImVec2(3.0f, 2.0f);&#10;    style.TouchExtraPadding    = ImVec2(0.0f, 0.0f);&#10;&#10;&#10;    style.IndentSpacing        = 12.0f;&#10;    style.ScrollbarSize        = 12.0f;&#10;    style.GrabMinSize          = 8.0f;&#10;&#10;    // Borders&#10;    style.WindowBorderSize     = 0.0f;&#10;    style.ChildBorderSize      = 0.0f;&#10;    style.PopupBorderSize      = 0.0f;&#10;    style.FrameBorderSize      = 0.0f;&#10;    style.TabBorderSize        = 0.0f;&#10;&#10;    // Rounding&#10;    style.WindowRounding       = 2.0f;&#10;    style.ChildRounding        = 4.0f;&#10;    style.FrameRounding        = 2.0f;&#10;    style.PopupRounding        = 4.0f;&#10;    style.ScrollbarRounding    = 9.0f;&#10;    style.GrabRounding         = 2.0f;&#10;    style.LogSliderDeadzone    = 4.0f;&#10;    style.TabRounding          = 4.0f;&#10;&#10;    // Alignment&#10;    style.WindowTitleAlign     = ImVec2(0.00f, 0.50f);&#10;    style.WindowMenuButtonPosition = ImGuiDir_Left;&#10;    style.ColorButtonPosition = ImGuiDir_Right;&#10;    style.ButtonTextAlign      = ImVec2(0.50f, 0.50f);&#10;    style.SelectableTextAlign  = ImVec2(0.00f, 0.00f);&#10;&#10;    // Safe Area Padding&#10;    style.DisplaySafeAreaPadding = ImVec2(3.0f, 3.0f);&#10;}&#10;&#10;void Application::SetupFont() noexcept {&#10;    ImGuiIO&amp; io = ImGui::GetIO();&#10;    &#10;    const char* fontPaths[] = {&#10;        &quot;/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf&quot;,&#10;        &quot;/usr/share/fonts/TTF/arial.ttf&quot;,&#10;        &quot;/System/Library/Fonts/Helvetica.ttc&quot;,&#10;        &quot;/Windows/Fonts/arial.ttf&quot;,&#10;        &quot;/Windows/Fonts/segoeui.ttf&quot;&#10;    };&#10;    &#10;    for (const char* fontPath : fontPaths) {&#10;        if (std::filesystem::exists(fontPath)) {&#10;            ImFontConfig config;&#10;            config.OversampleH = 3;&#10;            config.OversampleV = 2;&#10;            config.PixelSnapH = true;&#10;            io.Fonts-&gt;AddFontFromFileTTF(fontPath, 12.0f, &amp;config);&#10;            return;&#10;        }&#10;    }&#10;    &#10;    ImFontConfig config;&#10;    config.SizePixels = 14.0f;&#10;    config.OversampleH = 3;&#10;    config.OversampleV = 2;&#10;    config.PixelSnapH = true;&#10;    io.Fonts-&gt;AddFontDefault(&amp;config);&#10;}&#10;&#10;void Application::CreateWindow() {&#10;    spdlog::info(&quot;Creating window...&quot;);&#10;    int displayIndex = 0;&#10;    int mouseX, mouseY;&#10;    SDL_GetGlobalMouseState(&amp;mouseX, &amp;mouseY);&#10;    int numDisplays = SDL_GetNumVideoDisplays();&#10;&#10;    for (int i = 0; i &lt; numDisplays; i++) {&#10;        SDL_Rect displayBounds;&#10;        if (SDL_GetDisplayBounds(i, &amp;displayBounds) == 0 &amp;&amp;&#10;            mouseX &gt;= displayBounds.x &amp;&amp; mouseX &lt; displayBounds.x + displayBounds.w &amp;&amp;&#10;            mouseY &gt;= displayBounds.y &amp;&amp; mouseY &lt; displayBounds.y + displayBounds.h) {&#10;            displayIndex = i;&#10;            break;&#10;        }&#10;    }&#10;&#10;    m_window = SDL_CreateWindow(&quot;Negentropy - Diagram Editor&quot;,&#10;                                SDL_WINDOWPOS_CENTERED_DISPLAY(displayIndex),&#10;                                SDL_WINDOWPOS_CENTERED_DISPLAY(displayIndex), 1280, 720,&#10;                                SDL_WINDOW_HIDDEN | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);&#10;    if (!m_window) {&#10;        SDL_Quit();&#10;        throw std::runtime_error(&quot;SDL_CreateWindow error: &quot; + std::string(SDL_GetError()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Main/DiagramData.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Main/DiagramData.cpp" />
              <option name="originalContent" value="#include &quot;DiagramData.hpp&quot;&#10;#include &lt;pugixml.hpp&gt;&#10;#include &lt;iostream&gt;&#10;#include &quot;../Utils/Path.hpp&quot;&#10;#include &quot;../Diagram/Block.hpp&quot;&#10;#include &quot;../Utils/Notification.hpp&quot;&#10;&#10;DiagramData::DiagramData() noexcept {&#10;    Load((Utils::GetWorkspacePath() / &quot;Default.xml&quot;).string());&#10;}&#10;&#10;void DiagramData::Load(const std::string&amp; filePath) {&#10;    pugi::xml_document doc;&#10;    pugi::xml_parse_result result = doc.load_file(filePath.c_str());&#10;    if (!result) {&#10;        std::cerr &lt;&lt; &quot;Error loading file: &quot; &lt;&lt; result.description() &lt;&lt; std::endl;&#10;        return;&#10;    }&#10;&#10;    m_components.clear();&#10;    auto diagram = doc.child(&quot;Diagram&quot;);&#10;    if (!diagram) return;&#10;&#10;    if (auto cameraNode = diagram.child(&quot;Camera&quot;)) {&#10;        m_camera.xml_deserialize(cameraNode);&#10;    }&#10;&#10;    if (auto gridNode = diagram.child(&quot;Grid&quot;)) {&#10;        m_grid.xml_deserialize(gridNode);&#10;    }&#10;&#10;    auto loadComponents = [&amp;](pugi::xml_node parent) {&#10;        for (pugi::xml_node componentNode : parent.children()) {&#10;            if (auto component = CreateComponent(componentNode.name())) {&#10;                component-&gt;xml_deserialize(componentNode);&#10;                m_components.push_back(std::move(component));&#10;            }&#10;        }&#10;    };&#10;&#10;    if (auto componentsNode = diagram.child(&quot;Components&quot;)) {&#10;        loadComponents(componentsNode);&#10;    }&#10;}&#10;&#10;void DiagramData::Save(const std::string&amp; filePath) const {&#10;    pugi::xml_document doc;&#10;    auto declarationNode = doc.append_child(pugi::node_declaration);&#10;    declarationNode.append_attribute(&quot;version&quot;) = &quot;1.0&quot;;&#10;    declarationNode.append_attribute(&quot;encoding&quot;) = &quot;UTF-8&quot;;&#10;&#10;    auto diagram = doc.append_child(&quot;Diagram&quot;);&#10;&#10;    auto cameraNode = diagram.append_child(&quot;Camera&quot;);&#10;    m_camera.xml_serialize(cameraNode);&#10;&#10;    auto gridNode = diagram.append_child(&quot;Grid&quot;);&#10;    m_grid.xml_serialize(gridNode);&#10;&#10;    auto componentsNode = diagram.append_child(&quot;Components&quot;);&#10;    for (const auto&amp; component : m_components) {&#10;        auto typeName = component-&gt;GetTypeName();&#10;        auto componentNode = componentsNode.append_child(typeName.c_str());&#10;        component-&gt;xml_serialize(componentNode);&#10;    }&#10;&#10;    if(doc.save_file(filePath.c_str())) {&#10;        Notify::Success(&quot;Diagram saved successfully!&quot;);&#10;    } else {&#10;        Notify::Error(&quot;Error saving diagram!&quot;);&#10;    }&#10;}&#10;&#10;std::unique_ptr&lt;Diagram::ComponentBase&gt; DiagramData::CreateComponent(const std::string&amp; type) const {&#10;    if (type == &quot;Block&quot;) return std::make_unique&lt;Diagram::Block&gt;();&#10;    return nullptr;&#10;}&#10;&#10;void DiagramData::AddBlock(bool useCursorPosition, SDL_Window* window) noexcept&#10;{&#10;    size_t blockCount = GetComponentsOfType&lt;Diagram::Block&gt;().size();&#10;&#10;    auto newBlock = std::make_unique&lt;Diagram::Block&gt;();&#10;&#10;    if (useCursorPosition &amp;&amp; window) {&#10;        ImVec2 mousePos = ImGui::GetMousePos();&#10;&#10;        int w, h;&#10;        SDL_GetWindowSize(window, &amp;w, &amp;h);&#10;        glm::vec2 screenCenter(w / 2.0f, h / 2.0f);&#10;&#10;        newBlock-&gt;data.position.x = (mousePos.x - screenCenter.x) / m_camera.data.zoom + m_camera.data.position.x;&#10;        newBlock-&gt;data.position.y = (mousePos.y - screenCenter.y) / m_camera.data.zoom + m_camera.data.position.y;&#10;    } else {&#10;        newBlock-&gt;data.position = {100.0f + static_cast&lt;float&gt;(blockCount + 1) * 150.0f, 100.0f};&#10;    }&#10;&#10;    newBlock-&gt;data.label = &quot;Block &quot; + std::to_string(blockCount + 1);&#10;    m_components.push_back(std::move(newBlock));&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;DiagramData.hpp&quot;&#10;#include &lt;pugixml.hpp&gt;&#10;#include &lt;iostream&gt;&#10;#include &quot;../Utils/Path.hpp&quot;&#10;#include &quot;../Diagram/Block.hpp&quot;&#10;#include &quot;../Utils/Notification.hpp&quot;&#10;&#10;DiagramData::DiagramData() noexcept {&#10;    Load((Utils::GetWorkspacePath() / &quot;Default.xml&quot;).string());&#10;}&#10;&#10;void DiagramData::Load(const std::string&amp; filePath) {&#10;    pugi::xml_document doc;&#10;    pugi::xml_parse_result result = doc.load_file(filePath.c_str());&#10;    if (!result) {&#10;        std::cerr &lt;&lt; &quot;Error loading file: &quot; &lt;&lt; result.description() &lt;&lt; std::endl;&#10;        return;&#10;    }&#10;&#10;    m_components.clear();&#10;    auto diagram = doc.child(&quot;Diagram&quot;);&#10;    if (!diagram) return;&#10;&#10;    if (auto cameraNode = diagram.child(&quot;Camera&quot;)) {&#10;        m_camera.xml_deserialize(cameraNode);&#10;    }&#10;&#10;    if (auto gridNode = diagram.child(&quot;Grid&quot;)) {&#10;        m_grid.xml_deserialize(gridNode);&#10;    }&#10;&#10;    auto loadComponents = [&amp;](pugi::xml_node parent) {&#10;        for (pugi::xml_node componentNode : parent.children()) {&#10;            if (auto component = CreateComponent(componentNode.name())) {&#10;                component-&gt;xml_deserialize(componentNode);&#10;                m_components.push_back(std::move(component));&#10;            }&#10;        }&#10;    };&#10;&#10;    if (auto componentsNode = diagram.child(&quot;Components&quot;)) {&#10;        loadComponents(componentsNode);&#10;    }&#10;}&#10;&#10;void DiagramData::Save(const std::string&amp; filePath) const {&#10;    pugi::xml_document doc;&#10;    auto declarationNode = doc.append_child(pugi::node_declaration);&#10;    declarationNode.append_attribute(&quot;version&quot;) = &quot;1.0&quot;;&#10;    declarationNode.append_attribute(&quot;encoding&quot;) = &quot;UTF-8&quot;;&#10;&#10;    auto diagram = doc.append_child(&quot;Diagram&quot;);&#10;&#10;    auto cameraNode = diagram.append_child(&quot;Camera&quot;);&#10;    m_camera.xml_serialize(cameraNode);&#10;&#10;    auto gridNode = diagram.append_child(&quot;Grid&quot;);&#10;    m_grid.xml_serialize(gridNode);&#10;&#10;    auto componentsNode = diagram.append_child(&quot;Components&quot;);&#10;    for (const auto&amp; component : m_components) {&#10;        auto typeName = component-&gt;GetTypeName();&#10;        auto componentNode = componentsNode.append_child(typeName.c_str());&#10;        component-&gt;xml_serialize(componentNode);&#10;    }&#10;&#10;    if(doc.save_file(filePath.c_str())) {&#10;        Notify::Success(&quot;Diagram saved successfully!&quot;);&#10;    } else {&#10;        Notify::Error(&quot;Error saving diagram!&quot;);&#10;    }&#10;}&#10;&#10;std::unique_ptr&lt;Diagram::ComponentBase&gt; DiagramData::CreateComponent(const std::string&amp; type) const {&#10;    if (type == &quot;Block&quot;) return std::make_unique&lt;Diagram::Block&gt;();&#10;    return nullptr;&#10;}&#10;&#10;void DiagramData::AddBlock(bool useCursorPosition, SDL_Window* window) noexcept&#10;{&#10;    size_t blockCount = GetComponentsOfType&lt;Diagram::Block&gt;().size();&#10;&#10;    auto newBlock = std::make_unique&lt;Diagram::Block&gt;();&#10;&#10;    if (useCursorPosition &amp;&amp; window) {&#10;        ImVec2 mousePos = ImGui::GetMousePos();&#10;&#10;        int w, h;&#10;        SDL_GetWindowSize(window, &amp;w, &amp;h);&#10;        glm::vec2 screenCenter(w / 2.0f, h / 2.0f);&#10;&#10;        newBlock-&gt;data.position.x = (mousePos.x - screenCenter.x) / m_camera.data.zoom + m_camera.data.position.x;&#10;        newBlock-&gt;data.position.y = (mousePos.y - screenCenter.y) / m_camera.data.zoom + m_camera.data.position.y;&#10;    } else {&#10;        newBlock-&gt;data.position = m_camera.data.position - newBlock-&gt;data.size / 2.0f;&#10;    }&#10;&#10;    newBlock-&gt;data.label = &quot;Block &quot; + std::to_string(blockCount + 1);&#10;    m_components.push_back(std::move(newBlock));&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Core/Main/DiagramData.hpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Core/Main/DiagramData.hpp" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &lt;memory&gt;&#10;#include &quot;../Diagram/Component.hpp&quot;&#10;#include &quot;../Diagram/Block.hpp&quot;&#10;#include &quot;../Diagram/Camera.hpp&quot;&#10;#include &quot;../Diagram/Grid.hpp&quot;&#10;&#10;class DiagramData {&#10;public:&#10;    DiagramData() noexcept;&#10;&#10;    DiagramData(const DiagramData&amp;) = delete;&#10;    DiagramData&amp; operator=(const DiagramData&amp;) = delete;&#10;    DiagramData(DiagramData&amp;&amp;) = delete;&#10;    DiagramData&amp; operator=(DiagramData&amp;&amp;) = delete;&#10;&#10;    void Load(const std::string&amp; filePath);&#10;    void Save(const std::string&amp; filePath) const;&#10;&#10;    const std::vector&lt;std::unique_ptr&lt;Diagram::ComponentBase&gt;&gt;&amp; GetComponents() const noexcept { return m_components; }&#10;    std::vector&lt;std::unique_ptr&lt;Diagram::ComponentBase&gt;&gt;&amp; GetComponents() noexcept { return m_components; }&#10;    &#10;    template&lt;typename T&gt;&#10;    std::vector&lt;T*&gt; GetComponentsOfType() const noexcept {&#10;        std::vector&lt;T*&gt; result;&#10;        for (const auto&amp; comp : m_components) {&#10;            if (auto* typed = dynamic_cast&lt;T*&gt;(comp.get())) &#10;                result.push_back(typed);&#10;        }&#10;        return result;&#10;    }&#10;&#10;    const Diagram::Camera&amp; GetCamera() const noexcept { return m_camera; }&#10;    Diagram::Camera&amp; GetCamera() noexcept { return m_camera; }&#10;&#10;    const Diagram::Grid&amp; GetGrid() const noexcept { return m_grid; }&#10;    Diagram::Grid&amp; GetGrid() noexcept { return m_grid; }&#10;&#10;private:&#10;    std::unique_ptr&lt;Diagram::ComponentBase&gt; CreateComponent(const std::string&amp; type) const;&#10;    &#10;    std::vector&lt;std::unique_ptr&lt;Diagram::ComponentBase&gt;&gt; m_components;&#10;    Diagram::Camera m_camera;&#10;    Diagram::Grid m_grid;&#10;};&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &lt;string&gt;&#10;#include &lt;memory&gt;&#10;#include &quot;../Diagram/Component.hpp&quot;&#10;#include &quot;../Diagram/Block.hpp&quot;&#10;#include &quot;../Diagram/Camera.hpp&quot;&#10;#include &quot;../Diagram/Grid.hpp&quot;&#10;&#10;class DiagramData {&#10;public:&#10;    DiagramData() noexcept;&#10;&#10;    DiagramData(const DiagramData&amp;) = delete;&#10;    DiagramData&amp; operator=(const DiagramData&amp;) = delete;&#10;    DiagramData(DiagramData&amp;&amp;) = delete;&#10;    DiagramData&amp; operator=(DiagramData&amp;&amp;) = delete;&#10;&#10;    void Load(const std::string&amp; filePath);&#10;    void Save(const std::string&amp; filePath) const;&#10;&#10;    const std::vector&lt;std::unique_ptr&lt;Diagram::ComponentBase&gt;&gt;&amp; GetComponents() const noexcept { return m_components; }&#10;    std::vector&lt;std::unique_ptr&lt;Diagram::ComponentBase&gt;&gt;&amp; GetComponents() noexcept { return m_components; }&#10;    &#10;    template&lt;typename T&gt;&#10;    std::vector&lt;T*&gt; GetComponentsOfType() const noexcept {&#10;        std::vector&lt;T*&gt; result;&#10;        for (const auto&amp; comp : m_components) {&#10;            if (auto* typed = dynamic_cast&lt;T*&gt;(comp.get())) &#10;                result.push_back(typed);&#10;        }&#10;        return result;&#10;    }&#10;&#10;    const Diagram::Camera&amp; GetCamera() const noexcept { return m_camera; }&#10;    Diagram::Camera&amp; GetCamera() noexcept { return m_camera; }&#10;&#10;    const Diagram::Grid&amp; GetGrid() const noexcept { return m_grid; }&#10;    Diagram::Grid&amp; GetGrid() noexcept { return m_grid; }&#10;&#10;    void AddBlock(bool useCursorPosition = false, SDL_Window* window = nullptr) noexcept;&#10;&#10;private:&#10;    std::unique_ptr&lt;Diagram::ComponentBase&gt; CreateComponent(const std::string&amp; type) const;&#10;    &#10;    std::vector&lt;std::unique_ptr&lt;Diagram::ComponentBase&gt;&gt; m_components;&#10;    Diagram::Camera m_camera;&#10;    Diagram::Grid m_grid;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>